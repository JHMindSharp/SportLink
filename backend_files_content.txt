import os
from werkzeug.utils import secure_filename
from flask import current_app

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']

def save_file(file, folder):
    filename = secure_filename(file.filename)
    file_path = os.path.join(folder, filename)
    file.save(file_path)
    return file_path
"""
app/notifications/routes.py

This module defines routes for managing and displaying notifications in the SportLink application.
It allows users to view a list of their notifications.

Components:
- `list_notifications`: Displays a list of notifications for the logged-in user.
"""

from flask import Blueprint, render_template
from flask_login import login_required, current_user
from app.models import Notification

# Define the Blueprint for notification-related routes
notifications_bp = Blueprint('notifications', __name__)

@notifications_bp.route('/list', methods=['GET'])
@login_required
def list_notifications():
    """
    Displays a list of notifications for the current logged-in user.

    - Fetches the user's notifications from the database.
    - Orders notifications by their timestamp in descending order.

    Returns:
    - Rendered 'list.html' template with the user's notifications.
    """
    # Retrieve the current user's notifications, ordered by the timestamp
    notifications = current_user.notifications.order_by(Notification.timestamp.desc()).all()

    # Render the notifications template with the retrieved notifications
    return render_template('notifications/list.html', notifications=notifications)
# app/news_feed/routes.py

"""
app/news_feed/routes.py

Ce module définit les routes liées à la fonctionnalité de fil d'actualité
dans l'application SportLink. Il permet à l'utilisateur connecté de
voir les publications pertinentes (les siennes, celles de ses amis,
ainsi que tout post déclaré 'public').
"""

from flask import Blueprint, render_template, request
from flask_login import login_required, current_user
from app.models import Post
from app.extensions import db

# Définition du Blueprint pour les routes du fil d'actualité
news_feed_bp = Blueprint('news_feed', __name__, template_folder='templates/news_feed')

@news_feed_bp.route('/', methods=['GET'])
@login_required
def news_feed():
    """
    Affiche le fil d'actualité pour l'utilisateur connecté.

    Logique adoptée pour la visibilité des posts :
    1. Les publications créées par l'utilisateur (sans tenir compte de la visibilité).
    2. Les publications de ses amis (quelle que soit leur visibilité *ou* seulement public, 
       selon votre logique).
    3. Toutes les publications marquées 'public' (donc accessibles à tous).

    Remarque :
    - Si vous voulez que l'utilisateur ne voie que les posts "public" de ses amis (mais pas 
      leurs posts "private"), il suffit d'ajuster le filtre.

    Retourne :
    - Le template 'news_feed.html' avec la liste des posts à afficher.
    """
    # Récupérer la liste des IDs d'amis
    friends_ids = [friend.id for friend in current_user.friends]

    # Inclure l'ID du user courant pour afficher ses propres posts
    friends_ids.append(current_user.id)

    # Ici, on fusionne la logique de "posts/routes.py" et "news_feed/routes.py" 
    # pour n'avoir qu'une seule route de fil d'actualité.

    # On veut récupérer tous les posts qui proviennent de l'utilisateur courant 
    # ou de ses amis, + tous les posts 'public' de n'importe qui.
    # => Condition : (user_id dans friends_ids) OU (visibility == 'public')
    posts = Post.query.filter(
        (Post.user_id.in_(friends_ids)) | (Post.visibility == 'public')
    ).order_by(Post.created_at.desc()).all()

    # Rendre le template avec la liste des posts
    return render_template('news_feed/news_feed.html', posts=posts)
"""
app/news_feed/__init__.py

This module initializes the 'news_feed' Blueprint for handling the news feed functionality in the application.

Components:
- `news_feed_bp`: Blueprint instance for the news feed-related routes.
- Import of `routes`: Registers the routes related to the news feed.
"""

from flask import Blueprint

# Define the Blueprint for news feed-related functionalities
news_feed_bp = Blueprint('news_feed', __name__)

# Import routes to register them with the Blueprint
from app.news_feed import routes
# app/posts/routes.py

from flask import Blueprint, request, jsonify, render_template, redirect, url_for, flash, current_app
from flask_login import login_required, current_user
from datetime import datetime
import os
from werkzeug.utils import secure_filename

from app.models import Post, User
from app.extensions import db
from app.posts.forms import CreatePostForm

posts_bp = Blueprint('posts', __name__, template_folder='templates/posts')

@posts_bp.route('/create_post', methods=['GET', 'POST'])
@login_required
def create_post():
    """Version classique pour créer un post (séparée)."""
    form = CreatePostForm()
    if form.validate_on_submit():
        content_type = form.content_type.data
        title = form.title.data
        subtitle = form.subtitle.data
        content = form.content.data
        visibility = form.visibility.data

        image_file = form.image.data
        video_file = form.video.data
        music_file = form.music.data

        image_filename = None
        video_filename = None
        music_filename = None

        # Gérer l'upload
        if image_file:
            image_filename = secure_filename(image_file.filename)
            image_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'images', image_filename)
            image_file.save(image_path)
            image_filename = f'posts/images/{image_filename}'

        if video_file:
            video_filename = secure_filename(video_file.filename)
            video_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'videos', video_filename)
            video_file.save(video_path)
            video_filename = f'posts/videos/{video_filename}'

        if music_file:
            music_filename = secure_filename(music_file.filename)
            music_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'music', music_filename)
            music_file.save(music_path)
            music_filename = f'posts/music/{music_filename}'

        new_post = Post(
            user_id=current_user.id,
            content_type=content_type,
            title=title,
            subtitle=subtitle,
            content=content,
            image=image_filename,
            video=video_filename,
            music=music_filename,
            visibility=visibility,
            created_at=datetime.utcnow()
        )
        db.session.add(new_post)
        db.session.commit()
        flash("Publication créée avec succès.", "success")
        return redirect(url_for('profile.profile'))

    return render_template('posts/create_post.html', form=form)

@posts_bp.route('/create_post_inline', methods=['POST'])
@login_required
def create_post_inline():
    """Création inline d'un post (ex. sur le profil)."""
    content_type = request.form.get('content_type', 'free')
    title = request.form.get('title', '')
    content = request.form.get('content', '')
    visibility = request.form.get('visibility', 'public')

    image_file = request.files.get('image')
    video_file = request.files.get('video')
    music_file = request.files.get('music')

    image_filename = None
    video_filename = None
    music_filename = None

    # Gérer upload image
    if image_file and image_file.filename:
        img_filename = secure_filename(image_file.filename)
        img_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'images', img_filename)
        image_file.save(img_path)
        image_filename = f'posts/images/{img_filename}'

    if video_file and video_file.filename:
        vid_filename = secure_filename(video_file.filename)
        vid_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'videos', vid_filename)
        video_file.save(vid_path)
        video_filename = f'posts/videos/{vid_filename}'

    if music_file and music_file.filename:
        mus_filename = secure_filename(music_file.filename)
        mus_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'music', mus_filename)
        music_file.save(mus_path)
        music_filename = f'posts/music/{mus_filename}'

    new_post = Post(
        user_id=current_user.id,
        content_type=content_type,
        title=title,
        subtitle='',
        content=content,
        image=image_filename,
        video=video_filename,
        music=music_filename,
        visibility=visibility,
        created_at=datetime.utcnow()
    )
    db.session.add(new_post)
    db.session.commit()

    flash("Publication créée avec succès (inline).", "success")
    return redirect(url_for('profile.profile'))

@posts_bp.route('/delete_post/<int:post_id>', methods=['POST'])
@login_required
def delete_post(post_id):
    post = Post.query.get(post_id)
    if not post or post.user_id != current_user.id:
        flash("Publication introuvable ou vous n'avez pas la permission.", "danger")
        return redirect(url_for('profile.profile'))

    try:
        db.session.delete(post)
        db.session.commit()
        flash("Publication supprimée avec succès.", "success")
    except:
        db.session.rollback()
        flash("Erreur lors de la suppression de la publication.", "danger")

    return redirect(url_for('profile.profile'))

@posts_bp.route('/news_feed', methods=['GET'])
@login_required
def news_feed():
    """Route alternative si vous ne voulez pas /news_feed/. 
       Mais on a aussi app/news_feed/routes.py. 
       On peut la laisser ou la retirer selon l'architecture."""
    # Exemple simplifié
    friends_ids = [f.id for f in current_user.friends]
    posts = Post.query.filter(
        (Post.user_id.in_(friends_ids)) | (Post.visibility == 'public')
    ).order_by(Post.created_at.desc()).all()

    return render_template('posts/news_feed.html', posts=posts)
"""
app/posts/forms.py

This module defines forms related to post creation in the SportLink application.
It uses Flask-WTF for form handling and WTForms for validation.

Components:
- `CreatePostForm`: Form to create a post with options for content type, title, multimedia, and visibility.
"""

from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField, FileField, SubmitField, SelectField
from wtforms.validators import DataRequired
from flask_wtf.file import FileAllowed

class CreatePostForm(FlaskForm):
    """
    Form for creating a new post.

    Fields:
    - `content_type`: Dropdown to select the type of post (free or sport-related).
    - `title`: Optional text input for the post's title.
    - `subtitle`: Optional text input for the post's subtitle.
    - `content`: Text area for the main content of the post (required).
    - `image`: File upload field for an image (optional, accepts JPG, PNG, GIF).
    - `video`: File upload field for a video (optional, accepts MP4, AVI, MOV).
    - `music`: File upload field for an audio file (optional, accepts MP3, WAV).
    - `visibility`: Dropdown to set the post's visibility (public or private).
    - `submit`: Submit button to publish the post.
    """
    content_type = SelectField(
        'Type de Publication', 
        choices=[
            ('free', 'Publication Libre'), 
            ('sport', 'Publication Sportive')
        ], 
        validators=[DataRequired()]
    )
    title = StringField('Titre')
    subtitle = StringField('Sous-titre')
    content = TextAreaField(
        'Contenu', 
        validators=[DataRequired()]
    )
    image = FileField(
        'Ajouter une image', 
        validators=[FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')]
    )
    video = FileField(
        'Ajouter une vidéo', 
        validators=[FileAllowed(['mp4', 'avi', 'mov'], 'Vidéos uniquement!')]
    )
    music = FileField(
        'Ajouter de la musique', 
        validators=[FileAllowed(['mp3', 'wav'], 'Fichiers audio uniquement!')]
    )
    visibility = SelectField(
        'Visibilité', 
        choices=[
            ('public', 'Public'), 
            ('private', 'Privé')
        ], 
        validators=[DataRequired()]
    )
    submit = SubmitField('Publier')
"""
app/posts/__init__.py

This module initializes the 'posts' Blueprint, which handles functionalities related to user posts in the application.

Components:
- `posts_bp`: Blueprint instance for post-related routes.
- Import of `routes`: Registers the routes related to posts.
"""

from flask import Blueprint

# Define the Blueprint for post-related functionalities
posts_bp = Blueprint('posts', __name__)

# Import routes to register them with the Blueprint
from app.posts import routes
# app/main/routes.py

import os
from flask import Blueprint, render_template, jsonify, send_from_directory, current_app, redirect, url_for
from flask_login import current_user
from app.extensions import db
from app.auth.forms import RegistrationForm, LoginForm

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def index():
    """
    Si user est connecté => profil ou news_feed,
    Sinon => home page
    """
    if current_user.is_authenticated:
        return redirect(url_for('profile.profile'))
    register_form = RegistrationForm()
    login_form = LoginForm()
    return render_template('home.html', register_form=register_form, login_form=login_form)

@main_bp.app_errorhandler(404)
def not_found_error(error):
    register_form = RegistrationForm()
    login_form = LoginForm()
    return render_template('404.html', register_form=register_form, login_form=login_form), 404

@main_bp.app_errorhandler(500)
def internal_error(error):
    db.session.rollback()
    register_form = RegistrationForm()
    login_form = LoginForm()
    return render_template('500.html', register_form=register_form, login_form=login_form), 500

@main_bp.route('/uploads/<path:filename>')
def uploaded_file(filename):
    """
    Sert les fichiers uploadés depuis le dossier UPLOAD_FOLDER.
    """
    return send_from_directory(current_app.config['UPLOAD_FOLDER'], filename)

@main_bp.route('/privacy_policy')
def privacy_policy():
    return render_template('main/privacy_policy.html')
"""
app/__init__.py

This module initializes the Flask application and configures its extensions, blueprints, and other components.
"""

from flask import Flask
from flask_dance.contrib.facebook import make_facebook_blueprint
from flask_dance.contrib.strava import make_strava_blueprint
from app.extensions import db, migrate, bcrypt, jwt, mail, login_manager
from flask_wtf.csrf import CSRFProtect, generate_csrf
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Initialize CSRF protection
csrf = CSRFProtect()

def create_app():
    """
    Create and configure the Flask application.
    Returns:
        app (Flask): The configured Flask app.
    """
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_pyfile('config.py')
    
    # Initialize extensions
    db.init_app(app)
    migrate.init_app(app, db)
    bcrypt.init_app(app)
    jwt.init_app(app)
    mail.init_app(app)
    login_manager.init_app(app)
    
    # Enable CSRF protection for the app
    csrf.init_app(app)

    # Configure Flask-Login
    login_manager.login_view = 'auth.login'
    login_manager.login_message_category = 'info'
    
    # Register blueprints for modular routing
    from app.auth.routes import auth_bp
    from app.profile.routes import profile_bp
    from app.posts.routes import posts_bp
    from app.messages.routes import messages_bp
    from app.news_feed.routes import news_feed_bp
    from app.main.routes import main_bp
    from app.notifications.routes import notifications_bp
    from app.events.routes import events_bp
    
    app.register_blueprint(auth_bp, url_prefix='/auth')
    app.register_blueprint(profile_bp, url_prefix='/profile')
    app.register_blueprint(posts_bp, url_prefix='/posts')
    app.register_blueprint(messages_bp, url_prefix='/messages')
    app.register_blueprint(news_feed_bp, url_prefix='/news_feed')
    app.register_blueprint(main_bp)
    app.register_blueprint(notifications_bp, url_prefix='/notifications')
    app.register_blueprint(events_bp, url_prefix='/events')
    
    # Configure OAuth for Facebook
    facebook_bp = make_facebook_blueprint(
        client_id=app.config['FACEBOOK_OAUTH_CLIENT_ID'],
        client_secret=app.config['FACEBOOK_OAUTH_CLIENT_SECRET'],
        redirect_to='auth.oauth_facebook'
    )
    app.register_blueprint(facebook_bp, url_prefix='/facebook_login')
    
    # Configure OAuth for Strava
    strava_bp = make_strava_blueprint(
        client_id=app.config['STRAVA_OAUTH_CLIENT_ID'],
        client_secret=app.config['STRAVA_OAUTH_CLIENT_SECRET'],
        scope='read,profile:read_all',
        redirect_to='auth.oauth_strava'
    )
    app.register_blueprint(strava_bp, url_prefix='/strava_login')
    
    # Configure user loader for Flask-Login
    with app.app_context():
        from app.models import User
        
        @login_manager.user_loader
        def load_user(user_id):
            """
            Load a user by ID for Flask-Login.
            Args:
                user_id (int): The ID of the user.
            Returns:
                User: The user instance.
            """
            return User.query.get(int(user_id))

    # Inject global variables such as forms and CSRF tokens into templates
    from app.auth.forms import LoginForm, RegistrationForm
    
    @app.context_processor
    def inject_globals():
        """
        Inject global variables into templates.
        Returns:
            dict: A dictionary of global variables.
        """
        return dict(
            login_form=LoginForm(),
            register_form=RegistrationForm(),
            csrf_token=generate_csrf
        )
    
    return app
from datetime import datetime, date
from flask_login import UserMixin
from app.extensions import db, bcrypt
from sqlalchemy import UniqueConstraint

friends = db.Table('friends',
    db.Column('user_id', db.Integer, db.ForeignKey('user.id')),
    db.Column('friend_id', db.Integer, db.ForeignKey('user.id'))
)

class Sport(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), nullable=False, unique=True)
    user_sports = db.relationship('UserSport', back_populates='sport', lazy='dynamic', overlaps='user_sports')

class UserSport(db.Model):
    __tablename__ = 'user_sport'
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    sport_id = db.Column(db.Integer, db.ForeignKey('sport.id'), primary_key=True)
    level = db.Column(db.Integer, nullable=False)
    sport = db.relationship('Sport', back_populates='user_sports', overlaps='sports.user_sports')
    user = db.relationship('User', back_populates='user_sports', overlaps='sports.user_sports')

class Rating(db.Model):
    """Model representing a rating between users."""
    id = db.Column(db.Integer, primary_key=True)
    rater_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    rated_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    rating = db.Column(db.Integer, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<Rating {self.rating} from User {self.rater_id} to User {self.rated_id}>'

class Post(db.Model):
    """Model representing a post."""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    content_type = db.Column(db.String(20), nullable=False, default='free')
    title = db.Column(db.String(255), nullable=True)
    subtitle = db.Column(db.String(255), nullable=True)
    content = db.Column(db.Text, nullable=False)
    image = db.Column(db.String(255), nullable=True)
    video = db.Column(db.String(255), nullable=True)
    music = db.Column(db.String(255), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    visibility = db.Column(db.String(10), nullable=False, default='public')

    author = db.relationship('User', back_populates='posts')

    def __repr__(self):
        return f'<Post {self.id} - User {self.user_id}>'

class Notification(db.Model):
    """Model representing a notification."""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    message = db.Column(db.String(255), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    is_read = db.Column(db.Boolean, default=False)

    user = db.relationship('User', back_populates='notifications')

    def __repr__(self):
        return f'<Notification {self.id} for User {self.user_id}>'

class Message(db.Model):
    """Model representing a message between users."""
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    recipient_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    body = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, index=True, default=datetime.utcnow)

    sender = db.relationship('User', foreign_keys=[sender_id], backref='sent_messages')
    recipient = db.relationship('User', foreign_keys=[recipient_id], backref='received_messages')

    def __repr__(self):
        return f'<Message {self.id}>'

class User(db.Model, UserMixin):
    """Model representing a user."""
    __tablename__ = 'user'

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), index=True, unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    first_name = db.Column(db.String(64))
    last_name = db.Column(db.String(64))
    birth_date = db.Column(db.Date)
    gender = db.Column(db.String(10))
    profile_image = db.Column(db.String(255), nullable=True, default='default_profile.jpg')
    cover_image = db.Column(db.String(255), nullable=True, default='default_cover.jpg')
    profile_image_zoom = db.Column(db.Float, default=1.0)
    profile_image_pos_x = db.Column(db.Float, default=0.0)
    profile_image_pos_y = db.Column(db.Float, default=0.0)
    cover_image_zoom = db.Column(db.Float, default=1.0)
    cover_image_pos_x = db.Column(db.Float, default=0.0)
    cover_image_pos_y = db.Column(db.Float, default=0.0)
    country = db.Column(db.String(100), nullable=True)
    city = db.Column(db.String(100), nullable=True)
    address = db.Column(db.String(200), nullable=True)
    postal_code = db.Column(db.String(20), nullable=True)
    sex = db.Column(db.String(10), nullable=True)
    birth_date = db.Column(db.Date, nullable=True)
    phone = db.Column(db.String(20), nullable=True)
    display_phone = db.Column(db.Boolean, default=False)
    display_email = db.Column(db.Boolean, default=False)
    pending_email = db.Column(db.String(120), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    profile_completed = db.Column(db.Boolean, default=False)
    email_confirmed = db.Column(db.Boolean, default=False)
    provider = db.Column(db.String(50), nullable=True)
    provider_id = db.Column(db.String(100), nullable=True, unique=True)
    latitude = db.Column(db.Float, nullable=True)
    longitude = db.Column(db.Float, nullable=True)
    sport = db.Column(db.String(50), nullable=True)
    level = db.Column(db.String(50), nullable=True)
    strava_id = db.Column(db.String(64), nullable=True)
    facebook_id = db.Column(db.String(64), nullable=True)
    __table_args__ = (
        db.UniqueConstraint('strava_id', name='uq_user_strava_id'),
        db.UniqueConstraint('facebook_id', name='uq_user_facebook_id'),
    )
    # Relationships
    notifications = db.relationship('Notification', back_populates='user', lazy='dynamic')
    sports = db.relationship('UserSport', back_populates='user', lazy='dynamic', overlaps='user_sports')
    posts = db.relationship('Post', back_populates='author', cascade="all, delete-orphan", lazy='dynamic')
    ratings_received = db.relationship('Rating', foreign_keys='Rating.rated_id', backref='rated_user', lazy='dynamic')
    ratings_given = db.relationship('Rating', foreign_keys='Rating.rater_id', backref='rater_user', lazy='dynamic')
    friends = db.relationship(
        'User',
        secondary=friends,
        primaryjoin=(friends.c.user_id == id),
        secondaryjoin=(friends.c.friend_id == id),
        backref=db.backref('friend_of', lazy='dynamic'),
        lazy='dynamic'
    )
    user_sports = db.relationship('UserSport', back_populates='user', lazy='dynamic', overlaps='sports')

    def is_friend(self, user):
        return self.friends.filter(friends.c.friend_id == user.id).count() > 0

    def set_password(self, password):
        """Generate a password hash using bcrypt."""
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        """Check the password hash against the provided password."""
        return bcrypt.check_password_hash(self.password_hash, password)

    @property
    def age(self):
        """Calculate age based on birth_date."""
        if self.birth_date:
            today = date.today()
            return today.year - self.birth_date.year - (
                (today.month, today.day) < (self.birth_date.month, self.birth_date.day)
            )
        else:
            return None

    @property
    def average_rating(self):
        """Calculate average rating."""
        total_ratings = self.ratings_received.count()
        if total_ratings > 0:
            sum_ratings = sum([rating.rating for rating in self.ratings_received])
            return round(sum_ratings / total_ratings, 1)
        else:
            return None

    def get_sport_level(self, sport_id):
        """Get the level of the user for a specific sport."""
        user_sport = self.sports.filter_by(sport_id=sport_id).first()
        if user_sport:
            return user_sport.level
        else:
            return None

    def __repr__(self):
        return f'<User {self.username}>'
# app/profile/routes.py

from flask import Blueprint, request, render_template, redirect, url_for, flash, jsonify, current_app
from flask_login import login_required, current_user, logout_user
from datetime import datetime
import os
import uuid
from werkzeug.utils import secure_filename

from app.extensions import db
from app.models import User, Sport, Rating, Post, UserSport
from app.profile.forms import (
    EditProfileForm,
    ChangeEmailForm,
    ChangePasswordForm,
    DeleteAccountForm,
    CompleteProfileForm
)
from app.auth.forms import RegistrationForm, LoginForm
from flask_wtf import FlaskForm

profile_bp = Blueprint('profile', __name__)

class EmptyForm(FlaskForm):
    # Ce formulaire ne contient que le token caché
    pass

def save_image(image_file, folder_name, user_id):
    filename = secure_filename(image_file.filename)
    unique_prefix = str(uuid.uuid4())
    final_filename = f"{unique_prefix}_{filename}"

    user_folder = os.path.join(current_app.config['UPLOAD_FOLDER'], folder_name, str(user_id))
    os.makedirs(user_folder, exist_ok=True)

    file_path = os.path.join(user_folder, final_filename)
    image_file.save(file_path)
    return f"{folder_name}/{user_id}/{final_filename}"

@profile_bp.route('/settings', methods=['GET', 'POST'])
@login_required
def settings():
    change_email_form = ChangeEmailForm()
    change_password_form = ChangePasswordForm()
    delete_account_form = DeleteAccountForm()
    return render_template(
        'profile/settings.html',
        change_email_form=change_email_form,
        change_password_form=change_password_form,
        delete_account_form=delete_account_form
    )

@profile_bp.route('/change_email', methods=['POST'])
@login_required
def change_email():
    form = ChangeEmailForm()
    if form.validate_on_submit():
        current_user.email = form.email.data
        db.session.commit()
        flash("Votre adresse email a été mise à jour.", "success")
    else:
        flash("Erreur lors de la mise à jour de l'email.", "danger")
    return redirect(url_for('profile.settings'))

@profile_bp.route('/change_password', methods=['POST'])
@login_required
def change_password():
    form = ChangePasswordForm()
    if form.validate_on_submit():
        current_user.set_password(form.new_password.data)
        db.session.commit()
        flash("Votre mot de passe a été mis à jour. Veuillez vous reconnecter.", "success")
        logout_user()
        return redirect(url_for('auth.login'))
    else:
        flash("Erreur lors de la mise à jour du mot de passe.", "danger")
    return redirect(url_for('profile.settings'))

@profile_bp.route('/delete_account', methods=['POST'])
@login_required
def delete_account():
    form = DeleteAccountForm()
    if form.validate_on_submit():
        user = current_user._get_current_object()
        if isinstance(user, User):
            db.session.delete(user)
            db.session.commit()
            logout_user()
            flash("Votre compte a été supprimé.", "success")
            return redirect(url_for('main.index'))
        else:
            flash("Erreur lors de la suppression du compte.", "danger")
    else:
        flash("Erreur lors de la validation du formulaire.", "danger")
    return redirect(url_for('profile.settings'))

@profile_bp.route('/profile', methods=['GET'])
@login_required
def profile():
    """Affiche la page de profil du current_user (ou param user_id si voulu)."""
    user = current_user
    average_rating = user.average_rating
    total_ratings = user.ratings_received.count()
    posts = user.posts.order_by(Post.created_at.desc()).all()
    sports = Sport.query.all()
    form = EmptyForm()

    return render_template(
        'profile/profile.html',
        user=user,
        average_rating=average_rating,
        total_ratings=total_ratings,
        posts=posts,
        sports=sports,
        form=form
    )

@profile_bp.route('/profile/<int:user_id>', methods=['GET'])
@login_required
def profile_other(user_id):
    """Affiche le profil d'un autre utilisateur, si on veut user_id différent."""
    user = User.query.get_or_404(user_id)
    posts = user.posts.order_by(Post.created_at.desc()).all()
    return render_template('profile/profile.html', user=user, posts=posts)

@profile_bp.route('/edit_profile', methods=['GET', 'POST'])
@login_required
def edit_profile():
    user = current_user
    form = EditProfileForm()

    if form.validate_on_submit():
        user.first_name = form.first_name.data
        user.last_name = form.last_name.data
        user.email = form.email.data
        user.city = form.city.data
        user.country = form.country.data
        user.phone = form.phone.data
        user.display_phone = form.display_phone.data
        user.display_email = form.display_email.data

        # S’il y a un fichier uploadé, on appelle save_image()
        if form.profile_image.data:
            user.profile_image = save_image(form.profile_image.data, 'profiles', user.id)
        # Sinon, on NE change pas user.profile_image.
        # S’il était None, il le reste.

        if form.cover_image.data:
            user.cover_image = save_image(form.cover_image.data, 'covers', user.id)

        db.session.commit()
        flash("Profil mis à jour avec succès.", "success")
        return redirect(url_for('profile.profile'))

    # Pré-remplir
    form.first_name.data = user.first_name
    form.last_name.data = user.last_name
    form.email.data = user.email
    form.city.data = user.city
    form.country.data = user.country
    form.phone.data = user.phone
    form.display_phone.data = user.display_phone
    form.display_email.data = user.display_email

    return render_template('profile/edit_profile.html', form=form)
@profile_bp.route('/add_friend/<int:user_id>', methods=['POST'])
@login_required
def add_friend(user_id):
    user_to_add = User.query.get_or_404(user_id)
    if user_to_add == current_user:
        flash("Vous ne pouvez pas vous ajouter vous-même.", "danger")
        return redirect(url_for('profile.profile'))
    if current_user.is_friend(user_to_add):
        flash("Vous êtes déjà amis.", "info")
    else:
        current_user.friends.append(user_to_add)
        db.session.commit()
        flash(f"Vous êtes maintenant ami avec {user_to_add.first_name}.", "success")

    return redirect(url_for('profile.profile'))

@profile_bp.route('/friends', methods=['GET'])
@login_required
def list_friends():
    user = current_user
    friends = user.friends.all()
    return render_template('profile/friends_list.html', friends=friends, user=user)

@profile_bp.route('/photos/<int:user_id>', methods=['GET'])
@login_required
def photos(user_id):
    user = User.query.get_or_404(user_id)
    posts = Post.query.filter_by(user_id=user.id).filter(Post.image.isnot(None)).all()
    profile_images = [user.profile_image] if user.profile_image else []
    cover_images = [user.cover_image] if user.cover_image else []
    images = profile_images + cover_images + [p.image for p in posts if p.image]

    form = EmptyForm()

    if not images:
        flash("Aucune image disponible à afficher.", "info")

    return render_template('profile/photos.html', user=user, images=images, form=form)

@profile_bp.route('/complete_profile', methods=['GET', 'POST'])
@login_required
def complete_profile():
    """Exemple de formulaire WTForms plus poussé, si voulu."""
    form = CompleteProfileForm()
    form.sports.choices = [(str(s.id), s.name) for s in Sport.query.all()]
    form.levels.choices = [(str(i), f'{i} étoiles') for i in range(1, 6)]

    if form.validate_on_submit():
        current_user.birth_date = form.birth_date.data
        current_user.sex = form.sex.data

        if form.profile_image.data:
            profile_image_filename = save_image(form.profile_image.data, 'profiles', current_user.id)
            current_user.profile_image = profile_image_filename
        if form.cover_image.data:
            cover_image_filename = save_image(form.cover_image.data, 'covers', current_user.id)
            current_user.cover_image = cover_image_filename

        UserSport.query.filter_by(user_id=current_user.id).delete()
        selected_sports = form.sports.data
        selected_levels = form.levels.data
        for sport_id, level in zip(selected_sports, selected_levels):
            user_sport = UserSport(user_id=current_user.id, sport_id=int(sport_id), level=int(level))
            db.session.add(user_sport)

        current_user.profile_completed = True
        db.session.commit()
        flash('Profil complété avec succès!', 'success')
        return redirect(url_for('profile.profile'))

    return render_template('profile/complete_profile.html', form=form)

@profile_bp.route('/search_users', methods=['GET'])
@login_required
def search_users():
    query = request.args.get('query', '').strip()
    suggestions = []
    results = []

    if query:
        results = User.query.filter(
            (User.first_name.ilike(f'%{query}%')) | (User.last_name.ilike(f'%{query}%'))
        ).all()
    else:
        # Quelques suggestions. On peut filtrer par ville, etc.
        suggestions = User.query.filter(
            User.id != current_user.id
        ).limit(10).all()

    return render_template('profile/search_results.html', results=results, suggestions=suggestions, query=query)

@profile_bp.route('/add_contact/<int:user_id>', methods=['POST'])
@login_required
def add_contact(user_id):
    form = EmptyForm()
    if not form.validate_on_submit():
        flash("Erreur de soumission. Merci de réessayer.", "danger")
        return redirect(url_for('profile.list_contacts'))

    user_to_add = User.query.get_or_404(user_id)
    if user_to_add == current_user:
        flash("Vous ne pouvez pas vous ajouter vous-même.", "danger")
        return redirect(url_for('profile.list_contacts'))

    if current_user.is_friend(user_to_add):
        flash("Cette personne est déjà dans vos contacts.", "info")
    else:
        current_user.friends.append(user_to_add)
        db.session.commit()
        flash(f"{user_to_add.first_name} {user_to_add.last_name} a été ajouté à vos contacts.", "success")

    return redirect(url_for('profile.list_contacts'))

@profile_bp.route('/contacts', methods=['GET'])
@login_required
def list_contacts():
    contacts = current_user.friends.all()
    return render_template('profile/contacts.html', contacts=contacts)

@profile_bp.route('/remove_contact/<int:user_id>', methods=['POST'])
@login_required
def remove_contact(user_id):
    user_to_remove = User.query.get_or_404(user_id)
    if current_user.is_friend(user_to_remove):
        current_user.friends.remove(user_to_remove)
        db.session.commit()
        flash(f"{user_to_remove.first_name} {user_to_remove.last_name} a été retiré de vos contacts.", "success")
    else:
        flash("Cette personne n'est pas dans vos contacts.", "info")

    return redirect(url_for('profile.list_contacts'))
"""
app/profile/forms.py

This module defines forms related to user profile management in the SportLink application.
It includes functionalities for editing profile information, changing passwords, updating profile and cover photos,
completing the profile, and deleting the account.

Components:
- `ChangeEmailForm`: Form to change the user's email.
- `ChangePasswordForm`: Form to change the user's password.
- `DeleteAccountForm`: Form to confirm account deletion.
- `EditProfileForm`: Form to edit profile details.
- `ChangeCoverPhotoForm`: Form to update the cover photo.
- `ChangeProfilePhotoForm`: Form to update the profile photo.
- `CompleteProfileForm`: Form to complete profile details.
- `MultiCheckboxField`: Custom field for multi-checkbox selection.
"""

from flask_wtf import FlaskForm
from wtforms import (
    StringField, PasswordField, SubmitField, BooleanField, FileField,
    SelectField, DateField, HiddenField, TelField, FloatField, SelectMultipleField
)
from wtforms.validators import DataRequired, Email, EqualTo, ValidationError, Optional
from flask_wtf.file import FileAllowed
from app.models import User
from wtforms_sqlalchemy.fields import QuerySelectMultipleField
from wtforms.widgets import ListWidget, CheckboxInput

class ChangeEmailForm(FlaskForm):
    """
    Form to allow users to change their email address.

    Fields:
    - `email`: Input for the new email (validated for format and uniqueness).
    - `submit`: Submit button to confirm email update.

    Methods:
    - `validate_email`: Checks if the email is already in use.
    """
    email = StringField('Nouvelle adresse email', validators=[DataRequired(), Email()])
    submit = SubmitField('Mettre à jour l\'email')

    def validate_email(self, email):
        if User.query.filter_by(email=email.data).first():
            raise ValidationError('Cet email est déjà utilisé.')

class ChangePasswordForm(FlaskForm):
    """
    Form to allow users to change their password.

    Fields:
    - `current_password`: Input for the current password (required).
    - `new_password`: Input for the new password (required).
    - `confirm_new_password`: Confirmation for the new password (must match).
    - `submit`: Submit button to confirm password update.
    """
    current_password = PasswordField('Mot de passe actuel', validators=[DataRequired()])
    new_password = PasswordField('Nouveau mot de passe', validators=[DataRequired()])
    confirm_new_password = PasswordField('Confirmez le nouveau mot de passe', validators=[DataRequired(), EqualTo('new_password')])
    submit = SubmitField('Mettre à jour le mot de passe')

class DeleteAccountForm(FlaskForm):
    """
    Form to confirm account deletion.

    Fields:
    - `confirm`: Checkbox to confirm the action (required).
    - `submit`: Submit button to delete the account.
    """
    confirm = BooleanField('Je confirme vouloir supprimer mon compte', validators=[DataRequired()])
    submit = SubmitField('Supprimer mon compte')

class EditProfileForm(FlaskForm):
    """
    Form to edit user profile details.

    Fields include:
    - Basic information (username, email, first/last name, address, phone, etc.).
    - Profile and cover images (optional, restricted to image formats).
    - Location data (latitude, longitude).
    - Boolean fields for displaying phone and email publicly.
    - `submit`: Submit button to update the profile.
    """
    username = StringField('Nom d\'utilisateur', validators=[DataRequired()])
    email = StringField('Email', validators=[DataRequired(), Email()])
    first_name = StringField('Prénom')
    last_name = StringField('Nom de famille')
    country = StringField('Pays')
    city = StringField('Ville')
    address = StringField('Adresse')
    postal_code = StringField('Code Postal')
    sex = SelectField(
        'Sexe',
        choices=[
            ('', 'Sélectionnez'),
            ('Male', 'Homme'),
            ('Female', 'Femme'),
            ('Other', 'Autre')
        ],
        validators=[Optional()]
    )
    birth_date = DateField('Date de Naissance', format='%Y-%m-%d', validators=[Optional()])
    phone = TelField('Numéro de Téléphone')
    display_phone = BooleanField('Afficher le numéro de téléphone')
    display_email = BooleanField('Afficher l\'email')
    profile_image = FileField('Photo de Profil', validators=[FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')])
    cover_image = FileField('Image de Couverture', validators=[FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')])
    latitude = FloatField('Latitude')
    longitude = FloatField('Longitude')
    submit = SubmitField('Mettre à Jour')

class ChangeCoverPhotoForm(FlaskForm):
    """
    Form to update the user's cover photo.

    Fields:
    - `cover_image`: File upload field for the new cover photo (required, image formats only).
    - `submit`: Submit button to update the cover photo.
    """
    cover_image = FileField('Nouvelle photo de couverture', validators=[DataRequired(), FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')])
    submit = SubmitField('Mettre à jour')

class ChangeProfilePhotoForm(FlaskForm):
    """
    Form to update the user's profile photo.

    Fields:
    - `profile_image`: File upload field for the new profile photo (required, image formats only).
    - `submit`: Submit button to update the profile photo.
    """
    profile_image = FileField('Nouvelle photo de profil', validators=[DataRequired(), FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')])
    submit = SubmitField('Mettre à jour')

class CompleteProfileForm(FlaskForm):
    """
    Form to complete the user's profile.

    Fields:
    - `birth_date`: Date field for the user's birth date (required).
    - `sex`: Dropdown to select gender (required).
    - `profile_image`: File upload for profile photo (optional, image formats only).
    - `cover_image`: File upload for cover photo (optional, image formats only).
    - `sports`: Multi-select field for sports practiced (required).
    - `levels`: Multi-select field for experience levels (1 to 5 stars, required).
    - `submit`: Submit button to save profile details.
    """
    birth_date = DateField('Date de naissance', format='%Y-%m-%d', validators=[DataRequired()])
    sex = SelectField('Sexe', choices=[('male', 'Homme'), ('female', 'Femme'), ('other', 'Autre')], validators=[DataRequired()])
    profile_image = FileField('Photo de profil', validators=[FileAllowed(['jpg', 'png', 'jpeg'], 'Images seulement!')])
    cover_image = FileField('Photo de couverture', validators=[FileAllowed(['jpg', 'png', 'jpeg'], 'Images seulement!')])
    sports = SelectMultipleField('Sports pratiqués', choices=[], validators=[DataRequired()])
    levels = SelectMultipleField('Niveaux', choices=[(str(i), f'{i} étoiles') for i in range(1, 6)], validators=[DataRequired()])
    submit = SubmitField('Enregistrer')

class MultiCheckboxField(QuerySelectMultipleField):
    """
    Custom field for rendering multiple checkboxes in a form.

    - Inherits from `QuerySelectMultipleField`.
    - Uses `ListWidget` and `CheckboxInput` for rendering.
    """
    widget = ListWidget(prefix_label=False)
    option_widget = CheckboxInput()
"""
app/profile/__init__.py

This module initializes the 'profile' Blueprint, which handles functionalities related to user profiles in the application.

Components:
- `profile_bp`: Blueprint instance for profile-related routes.
- Import of `routes`: Registers the routes associated with the profile Blueprint.
"""

from flask import Blueprint

# Define the Blueprint for profile-related functionalities
profile_bp = Blueprint('profile', __name__)

# Import routes to register them with the Blueprint
from app.profile import routes
from flask import Blueprint, request, render_template, redirect, url_for, flash, current_app
from flask_login import login_user, logout_user, login_required, current_user
from app.models import User
from app.extensions import db, mail
from itsdangerous import URLSafeTimedSerializer
from flask_mail import Message
from app.auth.forms import RegistrationForm, LoginForm, ResetPasswordRequestForm, ResetPasswordForm
from flask_dance.contrib.strava import strava
from flask_dance.contrib.facebook import facebook
from app.utils.uploads_utils import allowed_file, save_file

# Define the authentication blueprint
auth_bp = Blueprint('auth', __name__)

# ============================
# OAuth Authentication Routes
# ============================

@auth_bp.route('/oauth_strava')
def oauth_strava():
    if not strava.authorized:
        current_app.logger.warning("Utilisateur non autorisé, redirection vers la connexion.")
        return redirect(url_for('auth.login'))

    token = strava.token
    current_app.logger.debug(f"Token Strava : {token}")

    resp = strava.get('/athlete')
    current_app.logger.info(f"Statut de la réponse : {resp.status_code}")
    current_app.logger.debug(f"Contenu de la réponse : {resp.text}")

    if resp.status_code != 200:
        current_app.logger.error("Erreur lors de l'appel à l'API Strava.")
        flash("Erreur de récupération des données de Strava.", "danger")
        return redirect(url_for('auth.login'))

    try:
        info = resp.json()
        current_app.logger.info(f"Données utilisateur récupérées : {info}")
    except ValueError as e:
        current_app.logger.error(f"Erreur de décodage JSON : {e}")
        flash("Erreur de lecture des données de Strava.", "danger")
        return redirect(url_for('auth.login'))

    return create_or_get_user_from_strava(info)

def create_or_get_user_from_strava(info):
    email = info.get('email')
    first_name = info.get('firstname')
    last_name = info.get('lastname')
    strava_id = info.get('id')

    if not email:
        current_app.logger.error("Aucune adresse email n'a été fournie par Strava.")
        flash("Votre compte Strava ne fournit pas d'adresse email.", "danger")
        return redirect(url_for('auth.login'))

    user = User.query.filter_by(email=email).first()

    if not user:
        user = User(
            username=email.split('@')[0],
            email=email,
            first_name=first_name,
            last_name=last_name,
            strava_id=strava_id,
            provider='strava'
        )
        db.session.add(user)
        db.session.commit()
        login_user(user)
        flash('Inscription réussie via Strava !', 'success')
        return redirect(url_for('profile.complete_profile'))
    else:
        login_user(user)
        flash('Connexion réussie via Strava.', 'success')
        return redirect(url_for('profile.profile'))

@auth_bp.route('/oauth_facebook')
def oauth_facebook():
    if not facebook.authorized:
        current_app.logger.warning("Utilisateur non autorisé, redirection vers la connexion.")
        return redirect(url_for('auth.login'))

    resp = facebook.get('/me?fields=id,name,email,first_name,last_name')
    current_app.logger.info(f"Statut de la réponse : {resp.status_code}")
    current_app.logger.debug(f"Contenu de la réponse : {resp.text}")

    if resp.status_code != 200:
        current_app.logger.error("Erreur lors de l'appel à l'API Facebook.")
        flash("Erreur de récupération des données de Facebook.", "danger")
        return redirect(url_for('auth.login'))

    try:
        info = resp.json()
        current_app.logger.info(f"Données utilisateur récupérées : {info}")
    except ValueError as e:
        current_app.logger.error(f"Erreur de décodage JSON : {e}")
        flash("Erreur de lecture des données de Facebook.", "danger")
        return redirect(url_for('auth.login'))

    return create_or_get_user_from_facebook(info)

def create_or_get_user_from_facebook(info):
    email = info.get('email')
    first_name = info.get('first_name')
    last_name = info.get('last_name')
    facebook_id = info.get('id')

    if not email:
        current_app.logger.error("Aucune adresse email n'a été fournie par Facebook.")
        flash("Votre compte Facebook ne fournit pas d'adresse email.", "danger")
        return redirect(url_for('auth.login'))

    user = User.query.filter_by(email=email).first()

    if not user:
        user = User(
            username=email.split('@')[0],
            email=email,
            first_name=first_name,
            last_name=last_name,
            facebook_id=facebook_id,
            provider='facebook'
        )
        db.session.add(user)
        db.session.commit()
        login_user(user)
        flash('Inscription réussie via Facebook !', 'success')
        return redirect(url_for('profile.complete_profile'))
    else:
        login_user(user)
        flash('Connexion réussie via Facebook.', 'success')
        return redirect(url_for('profile.profile'))

# ============================
# User Authentication Routes
# ============================

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('profile.profile'))

    form = RegistrationForm()

    if form.validate_on_submit():
        email = form.email.data.strip().lower()
        phone = form.phone.data.strip()

        # Vérification si l'email ou le téléphone existent déjà
        existing_email = User.query.filter_by(email=email).first()
        existing_phone = User.query.filter_by(phone=phone).first()

        if existing_email:
            flash("Cette adresse email est déjà utilisée. Veuillez vous connecter ou en utiliser une autre.", "warning")
            return redirect(url_for('auth.login'))

        if existing_phone:
            flash("Ce numéro de téléphone est déjà utilisé. Veuillez vous connecter ou en utiliser un autre.", "warning")
            return redirect(url_for('auth.login'))

        try:
            user = User(
                email=email,
                first_name=form.first_name.data.strip().capitalize(),
                last_name=form.last_name.data.strip().capitalize(),
                birth_date=form.birth_date.data,
                phone=phone
            )
            user.set_password(form.password.data)
            db.session.add(user)
            db.session.commit()
            flash("Inscription réussie !", "success")
            login_user(user)
            return redirect(url_for('profile.profile'))
        except Exception as e:
            flash("Une erreur s'est produite lors de l'inscription. Veuillez réessayer.", "danger")
            current_app.logger.error(f"Erreur lors de l'inscription : {e}")

    if form.errors:
        current_app.logger.debug(f"Erreurs de validation : {form.errors}")

    return render_template('auth/register.html', form=form)

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('profile.profile'))

    form = LoginForm()

    if form.validate_on_submit():
        email = form.email.data.strip().lower()
        user = User.query.filter_by(email=email).first()

        if user is None or not user.check_password(form.password.data):
            flash("Email ou mot de passe invalide.", "danger")
            return redirect(url_for('auth.login'))

        login_user(user)
        flash("Connexion réussie.", "success")
        next_page = request.args.get('next')
        return redirect(next_page or url_for('profile.profile'))

    if form.errors:
        current_app.logger.debug(f"Erreurs de validation du formulaire : {form.errors}")

    return render_template('auth/login.html', form=form)

@auth_bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash("Vous avez été déconnecté.", "info")
    return redirect(url_for('main.index'))

# ============================
# Email and Password Management
# ============================

def send_confirmation_email(user_email):
    s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    token = s.dumps(user_email, salt='email-confirm-salt')
    confirm_url = url_for('auth.confirm_email', token=token, _external=True)
    html = render_template('auth/confirm_email.html', confirm_url=confirm_url)
    send_email('Veuillez confirmer votre email', [user_email], html)

@auth_bp.route('/confirm/<token>')
def confirm_email(token):
    s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    try:
        email = s.loads(token, salt='email-confirm-salt', max_age=3600)
    except Exception:
        flash("Le lien de confirmation est invalide ou a expiré.", "danger")
        return redirect(url_for('main.index'))

    user = User.query.filter_by(email=email).first_or_404()
    user.email_confirmed = True
    db.session.commit()
    flash("Votre email a été confirmé !", "success")
    return redirect(url_for('profile.profile'))

def send_email(subject, recipients, html_body):
    msg = Message(subject, recipients=recipients)
    msg.html = html_body
    mail.send(msg)

@auth_bp.route('/reset_password_request', methods=['GET', 'POST'])
def reset_password_request():
    if current_user.is_authenticated:
        return redirect(url_for('profile.profile'))
    form = ResetPasswordRequestForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        if user:
            send_password_reset_email(user)
        flash('Un email avec les instructions pour réinitialiser votre mot de passe a été envoyé.', 'info')
        return redirect(url_for('auth.login'))
    return render_template('auth/reset_password_request.html', form=form)

def send_password_reset_email(user):
    s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    token = s.dumps(user.email, salt='password-reset-salt')
    reset_url = url_for('auth.reset_password', token=token, _external=True)
    html = render_template('auth/reset_password_email.html', reset_url=reset_url)
    send_email('Réinitialisation de votre mot de passe', [user.email], html)

@auth_bp.route('/reset_password/<token>', methods=['GET', 'POST'])
def reset_password(token):
    if current_user.is_authenticated:
        logout_user()

    s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    try:
        email = s.loads(token, salt='password-reset-salt', max_age=3600)
    except Exception:
        flash('Le lien de réinitialisation est invalide ou a expiré.', 'danger')
        return redirect(url_for('auth.reset_password_request'))

    form = ResetPasswordForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=email).first_or_404()
        user.set_password(form.password.data)
        db.session.commit()
        flash('Votre mot de passe a été mis à jour. Veuillez vous reconnecter.', 'success')
        return redirect(url_for('auth.login'))

    return render_template('auth/reset_password.html', form=form, token=token)

@auth_bp.route('/upload/profile', methods=['POST'])
def upload_profile():
    if 'file' not in request.files:
        flash('No file part')
        return redirect(url_for('profile.complete_profile'))

    file = request.files['file']
    if file.filename == '':
        flash('No selected file')
        return redirect(url_for('profile.complete_profile'))

    if allowed_file(file.filename):
        folder = os.path.join(current_app.config['UPLOAD_FOLDER'], 'profiles')
        file_path = save_file(file, folder)
        flash(f'File uploaded successfully: {file_path}')
        return redirect(url_for('profile.view_profile'))
    else:
        flash('File type not allowed')
        return redirect(url_for('profile.complete_profile'))
"""
app/auth/forms.py

This module defines the forms used for user authentication and registration functionalities in the application.
It uses Flask-WTF for form handling and WTForms for form validation.

Components:
- `RegistrationForm`: Form for user registration with fields for personal details and validation.
- `LoginForm`: Form for user login with email and password.
- `ResetPasswordRequestForm`: Form to request a password reset by email.
- `ResetPasswordForm`: Form to reset the user's password.
"""

from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField, BooleanField, DateField, SelectField
from wtforms.validators import DataRequired, Email, EqualTo, ValidationError
from app.models import User
from markupsafe import Markup
from wtforms import StringField, PasswordField, SubmitField, DateField, SelectField, BooleanField
from wtforms.validators import DataRequired, Email, EqualTo, Length, Regexp, ValidationError

class RegistrationForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    first_name = StringField('Prénom', validators=[DataRequired(), Length(min=2, max=64)])
    last_name = StringField('Nom de famille', validators=[DataRequired(), Length(min=2, max=64)])
    birth_date = DateField('Date de naissance', format='%Y-%m-%d', validators=[DataRequired()])
    gender = SelectField('Genre', choices=[('male', 'Homme'), ('female', 'Femme'), ('other', 'Autre')], validators=[DataRequired()])
    phone = StringField(
        'Numéro de téléphone',
        validators=[
            DataRequired(),
            Regexp(r'^\+?\d{10,15}$', message="Entrez un numéro de téléphone valide.")
        ]
    )
    password = PasswordField('Mot de passe', validators=[DataRequired()])
    confirm_password = PasswordField(
        'Confirmez le mot de passe',
        validators=[DataRequired(), EqualTo('password')]
    )
    accept_terms = BooleanField(
        label=Markup(
        'J\'accepte les <a href="/privacy_policy" target="_blank">conditions d\'utilisation</a>'
    ),
    validators=[DataRequired(message="Vous devez accepter les conditions d'utilisation pour continuer.")]
)
    submit = SubmitField('Inscription')

    # Validation personnalisée pour vérifier si l'email est unique
    def validate_email(self, email):
        user = User.query.filter_by(email=email.data).first()
        if user:
            raise ValidationError('Cet email est déjà utilisé.')

# Form for user login
class LoginForm(FlaskForm):
    """
    This form collects the user's email and password for login.
    """
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Mot de passe', validators=[DataRequired()])
    submit = SubmitField('Connexion')

# Form for requesting a password reset
class ResetPasswordRequestForm(FlaskForm):
    """
    This form collects the user's email to send a password reset link.
    """
    email = StringField('Email', validators=[DataRequired(), Email()])
    submit = SubmitField('Réinitialiser le mot de passe')

# Form for resetting the user's password
class ResetPasswordForm(FlaskForm):
    """
    This form collects the new password and confirmation for resetting the user's password.
    """
    password = PasswordField('Nouveau mot de passe', validators=[DataRequired()])
    confirm_password = PasswordField('Confirmez le mot de passe', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Réinitialiser le mot de passe')
"""
app/auth/__init__.py

This module initializes the 'auth' Blueprint for the authentication-related routes in the application.
The Blueprint allows for modular organization of the code and keeps all authentication routes grouped together.

Components:
- `auth_bp`: Blueprint instance for authentication.
- `routes`: Imports the authentication routes to register them with the Blueprint.
"""

from flask import Blueprint

# Define the 'auth' Blueprint to handle authentication-related routes
auth_bp = Blueprint('auth', __name__)

# Import the routes associated with the 'auth' Blueprint
from app.auth import routes
"""
app/auth/utils.py

This module contains utility functions for user management in the authentication system.
It includes functionalities for password reset emails, token generation, and user registration for OAuth providers.

Components:
- `send_password_reset_email`: Sends a password reset email to the user.
- `generate_reset_token`: Generates a secure token for password reset.
- `register_user_if_new`: Registers a new user if they don't already exist in the database, typically for OAuth providers.
"""

from app.models import User
from app.extensions import db, mail
from flask_mail import Message
from flask import url_for, current_app
from itsdangerous import URLSafeTimedSerializer

def send_password_reset_email(user):
    """
    Sends a password reset email to the specified user.

    Parameters:
    - user: The User object representing the recipient.

    The email includes a secure token and a link for resetting the password.
    """
    token = generate_reset_token(user.email)
    msg = Message('Réinitialisation du mot de passe', recipients=[user.email])
    reset_url = url_for('auth.reset_password', token=token, _external=True)
    msg.body = f'Pour réinitialiser votre mot de passe, cliquez sur le lien suivant : {reset_url}'
    mail.send(msg)

def generate_reset_token(email):
    """
    Generates a secure token for password reset based on the user's email.

    Parameters:
    - email: The user's email address used to create the token.

    Returns:
    - A secure token that can be used to validate password reset requests.
    """
    serializer = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    return serializer.dumps(email, salt='password-reset-salt')

def register_user_if_new(provider, provider_id, email=None, username=None):
    """
    Checks if a user exists for a given OAuth provider and provider ID. If not, registers the user.

    Parameters:
    - provider: The name of the OAuth provider (e.g., 'facebook', 'strava').
    - provider_id: The unique ID provided by the OAuth provider for the user.
    - email: Optional email address of the user.
    - username: Optional username. If not provided, defaults to a combination of provider and provider ID.

    Returns:
    - The User object for the existing or newly created user.
    """
    user = User.query.filter_by(provider=provider, provider_id=provider_id).first()

    if not user:
        user = User(
            provider=provider,
            provider_id=provider_id,
            email=email,
            username=username or f"{provider}_{provider_id}"
        )
        db.session.add(user)
        db.session.commit()

    return user
# app/messages/routes.py

from flask import Blueprint, render_template, request, redirect, url_for, flash
from flask_login import login_required, current_user
from app.models import Message, User
from app.extensions import db

messages_bp = Blueprint('messages', __name__, template_folder='templates/messages')

@messages_bp.route('/inbox', methods=['GET'])
@login_required
def inbox():
    """
    Affiche la boîte de réception (messages reçus).
    """
    messages = Message.query.filter_by(recipient_id=current_user.id).order_by(Message.timestamp.desc()).all()
    return render_template('messages/inbox.html', messages=messages)

@messages_bp.route('/send_message/<int:user_id>', methods=['GET', 'POST'])
@login_required
def send_message(user_id):
    """
    Envoie un message à un utilisateur donné.
    """
    recipient = User.query.get_or_404(user_id)

    if request.method == 'POST':
        body = request.form.get('body')
        if not body:
            flash("Le message ne peut pas être vide.", "danger")
            return redirect(url_for('messages.send_message', user_id=user_id))
        
        message = Message(sender_id=current_user.id, recipient_id=recipient.id, body=body)
        db.session.add(message)
        db.session.commit()
        
        flash("Message envoyé avec succès.", "success")
        return redirect(url_for('messages.inbox'))

    return render_template('messages/send_message.html', recipient=recipient)
"""
app/messages/__init__.py

This module initializes the 'messages' Blueprint for handling messaging-related functionalities in the application.

Components:
- `messages_bp`: Blueprint instance for messaging-related routes.
- Import of `routes`: Registers the routes related to messaging.
"""

from flask import Blueprint

# Define the Blueprint for messaging-related functionalities
messages_bp = Blueprint('messages', __name__)

# Import routes to register them with the Blueprint
from app.messages import routes
# app/events/routes.py

from flask import Blueprint, render_template, request, flash, redirect, url_for
from flask_login import login_required, current_user
from app.events.form import EventForm
from app.extensions import db
from app.models import User

events_bp = Blueprint('events', __name__)

@events_bp.route('/organize', methods=['GET', 'POST'])
@login_required
def organize():
    """
    Permet de créer/rechercher une activité sportive 
    et d'afficher des partenaires potentiels.
    """
    form = EventForm()
    partners = []

    if form.validate_on_submit():
        # Exemple de matching
        # On suppose que user.sport/level existent ou qu'on matche autrement
        # Filtrage simplifié
        partners = User.query.filter(
            User.city == current_user.city
        ).all()
        
        if partners:
            flash("Recherche effectuée avec succès. Partenaires trouvés.", "success")
        else:
            flash("Aucun partenaire trouvé pour ces critères.", "warning")

    return render_template('events/organize.html', form=form, partners=partners)
"""
app/events/forms.py

This module defines the forms used for creating or searching events in the SportLink application.
It leverages Flask-WTF for form handling and WTForms for validation.

Components:
- `EventForm`: A form for users to specify event details when searching for sports partners.
"""

from flask_wtf import FlaskForm
from wtforms import StringField, IntegerField, DateField, SelectField, SubmitField
from wtforms.validators import DataRequired

class EventForm(FlaskForm):
    """
    Form for searching for sports partners based on activity preferences.

    Fields:
    - sport: Dropdown for selecting the type of sport.
    - level: Dropdown for selecting the skill level.
    - distance: Integer input for the maximum distance in kilometers.
    - date: Date picker for specifying the event date.
    - submit: Submit button to trigger the search action.
    """
    sport = SelectField(
        'Sport', 
        choices=[
            ('running', 'Course à pied'), 
            ('cycling', 'Cyclisme')
        ], 
        validators=[DataRequired()]
    )
    level = SelectField(
        'Niveau', 
        choices=[
            ('beginner', 'Débutant'), 
            ('intermediate', 'Intermédiaire'), 
            ('advanced', 'Avancé')
        ], 
        validators=[DataRequired()]
    )
    distance = IntegerField(
        'Distance maximale (km)', 
        validators=[DataRequired()]
    )
    date = DateField(
        'Date', 
        format='%Y-%m-%d', 
        validators=[DataRequired()]
    )
    submit = SubmitField('Rechercher des Partenaires')
"""
app/extensions.py

This module initializes and manages the extensions used throughout the SportLink application.
These extensions provide key functionalities such as database management, user authentication, 
password encryption, email handling, and JWT (JSON Web Token) support.

Components:
- `db`: SQLAlchemy for database operations.
- `migrate`: Flask-Migrate for database migrations.
- `bcrypt`: Flask-Bcrypt for password hashing.
- `jwt`: Flask-JWT-Extended for JSON Web Token authentication.
- `mail`: Flask-Mail for email sending.
- `login_manager`: Flask-Login for user session management.
"""

from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_bcrypt import Bcrypt
from flask_jwt_extended import JWTManager
from flask_mail import Mail
from flask_login import LoginManager

# ======================
# Extension Initialization
# ======================

# SQLAlchemy: Handles interactions with the database
db = SQLAlchemy()

# Flask-Migrate: Provides database schema migration tools
migrate = Migrate()

# Flask-Bcrypt: Used for hashing passwords
bcrypt = Bcrypt()

# Flask-JWT-Extended: Enables JSON Web Token authentication
jwt = JWTManager()

# Flask-Mail: Provides email-sending capabilities
mail = Mail()

# Flask-Login: Manages user sessions and authentication
login_manager = LoginManager()
