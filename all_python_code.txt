

========== ./app/utils/uploads_utils.py ==========

import os
from werkzeug.utils import secure_filename
from flask import current_app

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']

def save_file(file, folder):
    filename = secure_filename(file.filename)
    file_path = os.path.join(folder, filename)
    file.save(file_path)
    return file_path


========== ./app/notifications/routes.py ==========

"""
app/notifications/routes.py

This module defines routes for managing and displaying notifications in the SportLink application.
It allows users to view a list of their notifications.

Components:
- `list_notifications`: Displays a list of notifications for the logged-in user.
"""

from flask import Blueprint, render_template
from flask_login import login_required, current_user
from app.models import Notification

# Define the Blueprint for notification-related routes
notifications_bp = Blueprint('notifications', __name__)

@notifications_bp.route('/list', methods=['GET'])
@login_required
def list_notifications():
    """
    Displays a list of notifications for the current logged-in user.

    - Fetches the user's notifications from the database.
    - Orders notifications by their timestamp in descending order.

    Returns:
    - Rendered 'list.html' template with the user's notifications.
    """
    # Retrieve the current user's notifications, ordered by the timestamp
    notifications = current_user.notifications.order_by(Notification.timestamp.desc()).all()

    # Render the notifications template with the retrieved notifications
    return render_template('notifications/list.html', notifications=notifications)


========== ./app/news_feed/routes.py ==========

"""
app/news_feed/routes.py

This module defines routes related to the news feed functionality in the SportLink application.
The news feed allows users to view posts from their friends and public posts.

Components:
- `news_feed`: Displays the news feed with posts from friends, the current user, and public posts.
"""

from flask import Blueprint, render_template, request
from flask_login import login_required, current_user
from app.models import Post
from app.extensions import db

# Define the Blueprint for news feed-related routes
news_feed_bp = Blueprint('news_feed', __name__, template_folder='templates/news_feed')

@news_feed_bp.route('/', methods=['GET'])
@login_required
def news_feed():
    """
    Displays the news feed for the logged-in user.

    - Retrieves posts created by the current user, their friends, and public posts.
    - Orders posts by creation date in descending order.

    Process:
    - Fetch the IDs of the current user's friends.
    - Include the current user's ID in the list.
    - Query posts that are either:
      1. Created by the current user or their friends, and
      2. Visible as public posts or specific to the current user.

    Returns:
    - Rendered 'news_feed.html' template with the list of posts.
    """
    # Get IDs of the current user's friends
    friends_ids = [friend.id for friend in current_user.friends]

    # Include the current user's ID in the list of post sources
    friends_ids.append(current_user.id)

    # Query the database for posts from the current user, their friends, and public posts
    posts = Post.query.filter(
        (Post.user_id.in_(friends_ids)) &  # Posts from the current user and friends
        ((Post.visibility == 'public') | (Post.user_id == current_user.id))  # Public or specific to the user
    ).order_by(Post.created_at.desc()).all()

    # Render the news feed template with the retrieved posts
    return render_template('news_feed/news_feed.html', posts=posts)


========== ./app/news_feed/__init__.py ==========

"""
app/news_feed/__init__.py

This module initializes the 'news_feed' Blueprint for handling the news feed functionality in the application.

Components:
- `news_feed_bp`: Blueprint instance for the news feed-related routes.
- Import of `routes`: Registers the routes related to the news feed.
"""

from flask import Blueprint

# Define the Blueprint for news feed-related functionalities
news_feed_bp = Blueprint('news_feed', __name__)

# Import routes to register them with the Blueprint
from app.news_feed import routes


========== ./app/posts/routes.py ==========

"""
app/posts/routes.py

This module defines routes related to managing posts in the SportLink application.
It includes features for creating, deleting, and viewing posts in the news feed.

Components:
- `create_post`: Allows users to create a new post with multimedia and visibility settings.
- `delete_post`: Allows users to delete their own posts.
- `news_feed`: Displays posts from friends and public posts in a news feed format.
"""

from flask import Blueprint, request, jsonify, render_template, redirect, url_for, flash, current_app
from flask_login import login_required, current_user
from app.models import Post, User
from app.extensions import db
from werkzeug.utils import secure_filename
import os
from datetime import datetime
from app.posts.forms import CreatePostForm  # Import du formulaire

# Define the Blueprint for post-related routes
posts_bp = Blueprint('posts', __name__, template_folder='templates/posts')

@posts_bp.route('/create_post', methods=['GET', 'POST'])
@login_required
def create_post():
    """
    Handles the creation of a new post.

    GET:
    - Renders the post creation form.

    POST:
    - Validates the form submission.
    - Processes uploaded files (image, video, music) and saves them.
    - Creates a new post in the database with the provided details.

    Returns:
    - Redirects to the user's profile after successful post creation.
    - Renders the 'create_post.html' template on form validation failure.
    """
    form = CreatePostForm()
    if form.validate_on_submit():
        content_type = form.content_type.data
        title = form.title.data
        subtitle = form.subtitle.data
        content = form.content.data
        visibility = form.visibility.data

        # Handle uploaded files
        image_file = form.image.data
        video_file = form.video.data
        music_file = form.music.data

        image_filename = None
        video_filename = None
        music_filename = None

        if image_file:
            image_filename = secure_filename(image_file.filename)
            image_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'images', image_filename)
            image_file.save(image_path)
            image_filename = 'posts/images/' + image_filename

        if video_file:
            video_filename = secure_filename(video_file.filename)
            video_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'videos', video_filename)
            video_file.save(video_path)
            video_filename = 'posts/videos/' + video_filename

        if music_file:
            music_filename = secure_filename(music_file.filename)
            music_path = os.path.join(current_app.config['UPLOAD_FOLDER'], 'posts', 'music', music_filename)
            music_file.save(music_path)
            music_filename = 'posts/music/' + music_filename

        # Create a new post
        new_post = Post(
            user_id=current_user.id,
            content_type=content_type,
            title=title,
            subtitle=subtitle,
            content=content,
            image=image_filename,
            video=video_filename,
            music=music_filename,
            visibility=visibility,
            created_at=datetime.utcnow()
        )
        db.session.add(new_post)
        db.session.commit()
        flash("Publication créée avec succès.", "success")
        return redirect(url_for('profile.profile'))

    return render_template('posts/create_post.html', form=form)

@posts_bp.route('/delete_post/<int:post_id>', methods=['POST'])
@login_required
def delete_post(post_id):
    """
    Handles the deletion of a user's post.

    - Checks if the post exists and belongs to the current user.
    - Deletes the post from the database.

    Parameters:
    - `post_id`: ID of the post to be deleted.

    Returns:
    - Redirects to the user's profile after successful deletion.
    - Displays an error message if the post cannot be deleted.
    """
    post = Post.query.get(post_id)
    if not post or post.user_id != current_user.id:
        flash("Publication introuvable ou vous n'avez pas la permission de la supprimer.", "danger")
        return redirect(url_for('profile.profile'))

    try:
        db.session.delete(post)
        db.session.commit()
        flash("Publication supprimée avec succès.", "success")
    except:
        db.session.rollback()
        flash("Une erreur est survenue lors de la suppression de la publication.", "danger")

    return redirect(url_for('profile.profile'))

@posts_bp.route('/news_feed', methods=['GET'])
@login_required
def news_feed():
    """
    Displays the news feed for the current user.

    - Retrieves posts from the user's friends and public posts.
    - Orders posts by their creation date in descending order.

    Returns:
    - Rendered 'news_feed.html' template with the list of posts.
    """
    # Get IDs of the current user's friends
    friends_ids = [friend.id for friend in current_user.friends]

    # Query the database for posts from friends and public posts
    posts = Post.query.filter(
        (Post.user_id.in_(friends_ids)) |
        (Post.visibility == 'public')
    ).order_by(Post.created_at.desc()).all()

    # Render the news feed template with the retrieved posts
    return render_template('posts/news_feed.html', posts=posts)


========== ./app/posts/forms.py ==========

"""
app/posts/forms.py

This module defines forms related to post creation in the SportLink application.
It uses Flask-WTF for form handling and WTForms for validation.

Components:
- `CreatePostForm`: Form to create a post with options for content type, title, multimedia, and visibility.
"""

from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField, FileField, SubmitField, SelectField
from wtforms.validators import DataRequired
from flask_wtf.file import FileAllowed

class CreatePostForm(FlaskForm):
    """
    Form for creating a new post.

    Fields:
    - `content_type`: Dropdown to select the type of post (free or sport-related).
    - `title`: Optional text input for the post's title.
    - `subtitle`: Optional text input for the post's subtitle.
    - `content`: Text area for the main content of the post (required).
    - `image`: File upload field for an image (optional, accepts JPG, PNG, GIF).
    - `video`: File upload field for a video (optional, accepts MP4, AVI, MOV).
    - `music`: File upload field for an audio file (optional, accepts MP3, WAV).
    - `visibility`: Dropdown to set the post's visibility (public or private).
    - `submit`: Submit button to publish the post.
    """
    content_type = SelectField(
        'Type de Publication', 
        choices=[
            ('free', 'Publication Libre'), 
            ('sport', 'Publication Sportive')
        ], 
        validators=[DataRequired()]
    )
    title = StringField('Titre')
    subtitle = StringField('Sous-titre')
    content = TextAreaField(
        'Contenu', 
        validators=[DataRequired()]
    )
    image = FileField(
        'Ajouter une image', 
        validators=[FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')]
    )
    video = FileField(
        'Ajouter une vidéo', 
        validators=[FileAllowed(['mp4', 'avi', 'mov'], 'Vidéos uniquement!')]
    )
    music = FileField(
        'Ajouter de la musique', 
        validators=[FileAllowed(['mp3', 'wav'], 'Fichiers audio uniquement!')]
    )
    visibility = SelectField(
        'Visibilité', 
        choices=[
            ('public', 'Public'), 
            ('private', 'Privé')
        ], 
        validators=[DataRequired()]
    )
    submit = SubmitField('Publier')


========== ./app/posts/__init__.py ==========

"""
app/posts/__init__.py

This module initializes the 'posts' Blueprint, which handles functionalities related to user posts in the application.

Components:
- `posts_bp`: Blueprint instance for post-related routes.
- Import of `routes`: Registers the routes related to posts.
"""

from flask import Blueprint

# Define the Blueprint for post-related functionalities
posts_bp = Blueprint('posts', __name__)

# Import routes to register them with the Blueprint
from app.posts import routes


========== ./app/main/routes.py ==========

"""
app/main/routes.py

This module handles the main routes of the SportLink application, including:
- The home page
- Custom error handlers for 404 and 500 errors
- Serving uploaded files
- Displaying the privacy policy

Components:
- `index`: The home page route.
- `not_found_error`: Custom handler for 404 errors.
- `internal_error`: Custom handler for 500 errors.
- `uploaded_file`: Route to serve uploaded files.
- `privacy_policy`: Route to display the privacy policy.
"""

import os
from flask import Blueprint, render_template, jsonify, send_from_directory, current_app, redirect, url_for
from flask_login import current_user
from app.extensions import db
from app.auth.forms import RegistrationForm, LoginForm

# Define the blueprint for main routes
main_bp = Blueprint('main', __name__)

@main_bp.route('/')
def index():
    """
    Handles the root URL ('/') of the application.

    - If the user is authenticated, redirects to the profile page.
    - If the user is not authenticated, renders the home page with login and registration forms.

    Returns:
    - Redirect to the profile page if authenticated.
    - Render of 'home.html' with forms if not authenticated.
    """
    if current_user.is_authenticated:
        return redirect(url_for('profile.profile'))
    register_form = RegistrationForm()
    login_form = LoginForm()
    return render_template('home.html', register_form=register_form, login_form=login_form)

@main_bp.app_errorhandler(404)
def not_found_error(error):
    """
    Custom handler for 404 (Not Found) errors.

    - Renders a '404.html' template with login and registration forms.

    Parameters:
    - error: The error object for the 404 exception.

    Returns:
    - Rendered '404.html' with a 404 status code.
    """
    register_form = RegistrationForm()
    login_form = LoginForm()
    return render_template('404.html', register_form=register_form, login_form=login_form), 404

@main_bp.app_errorhandler(500)
def internal_error(error):
    """
    Custom handler for 500 (Internal Server Error) errors.

    - Rolls back the database session to avoid conflicts.
    - Renders a '500.html' template with login and registration forms.

    Parameters:
    - error: The error object for the 500 exception.

    Returns:
    - Rendered '500.html' with a 500 status code.
    """
    db.session.rollback()
    register_form = RegistrationForm()
    login_form = LoginForm()
    return render_template('500.html', register_form=register_form, login_form=login_form), 500

@main_bp.route('/uploads/<path:filename>')
def uploaded_file(filename):
    """
    Serves uploaded files from the configured upload folder.

    Parameters:
    - filename: The name of the file to be served.

    Returns:
    - The requested file from the upload directory.
    """
    return send_from_directory(current_app.config['UPLOAD_FOLDER'], filename)

@main_bp.route('/privacy_policy')
def privacy_policy():
    """
    Displays the privacy policy of the application.

    Returns:
    - Rendered 'privacy_policy.html' template.
    """
    return render_template('main/privacy_policy.html')


========== ./app/__init__.py ==========

"""
app/__init__.py

This module initializes the Flask application and configures its extensions, blueprints, and other components.
"""

from flask import Flask
from flask_dance.contrib.facebook import make_facebook_blueprint
from flask_dance.contrib.strava import make_strava_blueprint
from app.extensions import db, migrate, bcrypt, jwt, mail, login_manager
from flask_wtf.csrf import CSRFProtect, generate_csrf
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Initialize CSRF protection
csrf = CSRFProtect()

def create_app():
    """
    Create and configure the Flask application.
    Returns:
        app (Flask): The configured Flask app.
    """
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_pyfile('config.py')
    
    # Initialize extensions
    db.init_app(app)
    migrate.init_app(app, db)
    bcrypt.init_app(app)
    jwt.init_app(app)
    mail.init_app(app)
    login_manager.init_app(app)
    
    # Enable CSRF protection for the app
    csrf.init_app(app)

    # Configure Flask-Login
    login_manager.login_view = 'auth.login'
    login_manager.login_message_category = 'info'
    
    # Register blueprints for modular routing
    from app.auth.routes import auth_bp
    from app.profile.routes import profile_bp
    from app.posts.routes import posts_bp
    from app.messages.routes import messages_bp
    from app.news_feed.routes import news_feed_bp
    from app.main.routes import main_bp
    from app.notifications.routes import notifications_bp
    from app.events.routes import events_bp
    
    app.register_blueprint(auth_bp, url_prefix='/auth')
    app.register_blueprint(profile_bp, url_prefix='/profile')
    app.register_blueprint(posts_bp, url_prefix='/posts')
    app.register_blueprint(messages_bp, url_prefix='/messages')
    app.register_blueprint(news_feed_bp, url_prefix='/news_feed')
    app.register_blueprint(main_bp)
    app.register_blueprint(notifications_bp, url_prefix='/notifications')
    app.register_blueprint(events_bp, url_prefix='/events')
    
    # Configure OAuth for Facebook
    facebook_bp = make_facebook_blueprint(
        client_id=app.config['FACEBOOK_OAUTH_CLIENT_ID'],
        client_secret=app.config['FACEBOOK_OAUTH_CLIENT_SECRET'],
        redirect_to='auth.oauth_facebook'
    )
    app.register_blueprint(facebook_bp, url_prefix='/facebook_login')
    
    # Configure OAuth for Strava
    strava_bp = make_strava_blueprint(
        client_id=app.config['STRAVA_OAUTH_CLIENT_ID'],
        client_secret=app.config['STRAVA_OAUTH_CLIENT_SECRET'],
        scope='read,profile:read_all',
        redirect_to='auth.oauth_strava'
    )
    app.register_blueprint(strava_bp, url_prefix='/strava_login')
    
    # Configure user loader for Flask-Login
    with app.app_context():
        from app.models import User
        
        @login_manager.user_loader
        def load_user(user_id):
            """
            Load a user by ID for Flask-Login.
            Args:
                user_id (int): The ID of the user.
            Returns:
                User: The user instance.
            """
            return User.query.get(int(user_id))

    # Inject global variables such as forms and CSRF tokens into templates
    from app.auth.forms import LoginForm, RegistrationForm
    
    @app.context_processor
    def inject_globals():
        """
        Inject global variables into templates.
        Returns:
            dict: A dictionary of global variables.
        """
        return dict(
            login_form=LoginForm(),
            register_form=RegistrationForm(),
            csrf_token=generate_csrf
        )
    
    return app


========== ./app/models.py ==========

from datetime import datetime, date
from flask_login import UserMixin
from app.extensions import db, bcrypt
from sqlalchemy import UniqueConstraint

friends = db.Table('friends',
    db.Column('user_id', db.Integer, db.ForeignKey('user.id')),
    db.Column('friend_id', db.Integer, db.ForeignKey('user.id'))
)

class Sport(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), nullable=False, unique=True)
    user_sports = db.relationship('UserSport', back_populates='sport', lazy='dynamic', overlaps='user_sports')

class UserSport(db.Model):
    __tablename__ = 'user_sport'
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    sport_id = db.Column(db.Integer, db.ForeignKey('sport.id'), primary_key=True)
    level = db.Column(db.Integer, nullable=False)
    sport = db.relationship('Sport', back_populates='user_sports', overlaps='sports.user_sports')
    user = db.relationship('User', back_populates='user_sports', overlaps='sports.user_sports')

class Rating(db.Model):
    """Model representing a rating between users."""
    id = db.Column(db.Integer, primary_key=True)
    rater_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    rated_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    rating = db.Column(db.Integer, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f'<Rating {self.rating} from User {self.rater_id} to User {self.rated_id}>'

class Post(db.Model):
    """Model representing a post."""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    content_type = db.Column(db.String(20), nullable=False, default='free')
    title = db.Column(db.String(255), nullable=True)
    subtitle = db.Column(db.String(255), nullable=True)
    content = db.Column(db.Text, nullable=False)
    image = db.Column(db.String(255), nullable=True)
    video = db.Column(db.String(255), nullable=True)
    music = db.Column(db.String(255), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    visibility = db.Column(db.String(10), nullable=False, default='public')

    author = db.relationship('User', back_populates='posts')

    def __repr__(self):
        return f'<Post {self.id} - User {self.user_id}>'

class Notification(db.Model):
    """Model representing a notification."""
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    message = db.Column(db.String(255), nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    is_read = db.Column(db.Boolean, default=False)

    user = db.relationship('User', back_populates='notifications')

    def __repr__(self):
        return f'<Notification {self.id} for User {self.user_id}>'

class Message(db.Model):
    """Model representing a message between users."""
    id = db.Column(db.Integer, primary_key=True)
    sender_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    recipient_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    body = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, index=True, default=datetime.utcnow)

    sender = db.relationship('User', foreign_keys=[sender_id], backref='sent_messages')
    recipient = db.relationship('User', foreign_keys=[recipient_id], backref='received_messages')

    def __repr__(self):
        return f'<Message {self.id}>'

class User(db.Model, UserMixin):
    """Model representing a user."""
    __tablename__ = 'user'

    id = db.Column(db.Integer, primary_key=True)
    email = db.Column(db.String(120), index=True, unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    first_name = db.Column(db.String(64))
    last_name = db.Column(db.String(64))
    birth_date = db.Column(db.Date)
    gender = db.Column(db.String(10))
    profile_image = db.Column(db.String(255), nullable=True, default='default_profile.jpg')
    cover_image = db.Column(db.String(255), nullable=True, default='default_cover.jpg')
    profile_image_zoom = db.Column(db.Float, default=1.0)
    profile_image_pos_x = db.Column(db.Float, default=0.0)
    profile_image_pos_y = db.Column(db.Float, default=0.0)
    cover_image_zoom = db.Column(db.Float, default=1.0)
    cover_image_pos_x = db.Column(db.Float, default=0.0)
    cover_image_pos_y = db.Column(db.Float, default=0.0)
    country = db.Column(db.String(100), nullable=True)
    city = db.Column(db.String(100), nullable=True)
    address = db.Column(db.String(200), nullable=True)
    postal_code = db.Column(db.String(20), nullable=True)
    sex = db.Column(db.String(10), nullable=True)
    birth_date = db.Column(db.Date, nullable=True)
    phone = db.Column(db.String(20), nullable=True)
    display_phone = db.Column(db.Boolean, default=False)
    display_email = db.Column(db.Boolean, default=False)
    pending_email = db.Column(db.String(120), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    profile_completed = db.Column(db.Boolean, default=False)
    email_confirmed = db.Column(db.Boolean, default=False)
    provider = db.Column(db.String(50), nullable=True)
    provider_id = db.Column(db.String(100), nullable=True, unique=True)
    latitude = db.Column(db.Float, nullable=True)
    longitude = db.Column(db.Float, nullable=True)
    sport = db.Column(db.String(50), nullable=True)
    level = db.Column(db.String(50), nullable=True)
    strava_id = db.Column(db.String(64), nullable=True)
    facebook_id = db.Column(db.String(64), nullable=True)
    __table_args__ = (
        db.UniqueConstraint('strava_id', name='uq_user_strava_id'),
        db.UniqueConstraint('facebook_id', name='uq_user_facebook_id'),
    )
    # Relationships
    notifications = db.relationship('Notification', back_populates='user', lazy='dynamic')
    sports = db.relationship('UserSport', back_populates='user', lazy='dynamic', overlaps='user_sports')
    posts = db.relationship('Post', back_populates='author', cascade="all, delete-orphan", lazy='dynamic')
    ratings_received = db.relationship('Rating', foreign_keys='Rating.rated_id', backref='rated_user', lazy='dynamic')
    ratings_given = db.relationship('Rating', foreign_keys='Rating.rater_id', backref='rater_user', lazy='dynamic')
    friends = db.relationship(
        'User',
        secondary=friends,
        primaryjoin=(friends.c.user_id == id),
        secondaryjoin=(friends.c.friend_id == id),
        backref=db.backref('friend_of', lazy='dynamic'),
        lazy='dynamic'
    )
    user_sports = db.relationship('UserSport', back_populates='user', lazy='dynamic', overlaps='sports')

    def is_friend(self, user):
        return self.friends.filter(friends.c.friend_id == user.id).count() > 0

    def set_password(self, password):
        """Generate a password hash using bcrypt."""
        self.password_hash = bcrypt.generate_password_hash(password).decode('utf-8')

    def check_password(self, password):
        """Check the password hash against the provided password."""
        return bcrypt.check_password_hash(self.password_hash, password)

    @property
    def age(self):
        """Calculate age based on birth_date."""
        if self.birth_date:
            today = date.today()
            return today.year - self.birth_date.year - (
                (today.month, today.day) < (self.birth_date.month, self.birth_date.day)
            )
        else:
            return None

    @property
    def average_rating(self):
        """Calculate average rating."""
        total_ratings = self.ratings_received.count()
        if total_ratings > 0:
            sum_ratings = sum([rating.rating for rating in self.ratings_received])
            return round(sum_ratings / total_ratings, 1)
        else:
            return None

    def get_sport_level(self, sport_id):
        """Get the level of the user for a specific sport."""
        user_sport = self.sports.filter_by(sport_id=sport_id).first()
        if user_sport:
            return user_sport.level
        else:
            return None

    def __repr__(self):
        return f'<User {self.username}>'


========== ./app/profile/routes.py ==========

from flask import Blueprint, request, render_template, redirect, url_for, flash, jsonify, current_app
from flask_login import login_required, current_user, logout_user
from app.models import User, Sport, Rating, Post, UserSport
from app.extensions import db
from datetime import datetime
import os
import uuid
from werkzeug.utils import secure_filename
from app.profile.forms import (
    EditProfileForm,
    ChangeEmailForm,
    ChangePasswordForm,
    DeleteAccountForm,
    CompleteProfileForm
)
from app.auth.forms import RegistrationForm, LoginForm
from flask_wtf import FlaskForm


profile_bp = Blueprint('profile', __name__)

class EmptyForm(FlaskForm):
    pass

# Helper function to save images in user-specific folders
def save_image(image_file, folder_name, user_id):
    filename = secure_filename(image_file.filename)
    unique_prefix = str(uuid.uuid4())
    final_filename = f"{unique_prefix}_{filename}"

    user_folder = os.path.join(current_app.config['UPLOAD_FOLDER'], folder_name, str(user_id))
    os.makedirs(user_folder, exist_ok=True)

    file_path = os.path.join(user_folder, final_filename)
    image_file.save(file_path)
    return f"{user_id}/{final_filename}"

@profile_bp.route('/settings', methods=['GET', 'POST'])
@login_required
def settings():
    change_email_form = ChangeEmailForm()
    change_password_form = ChangePasswordForm()
    delete_account_form = DeleteAccountForm()
    return render_template('profile/settings.html', change_email_form=change_email_form, change_password_form=change_password_form, delete_account_form=delete_account_form)

@profile_bp.route('/change_email', methods=['POST'])
@login_required
def change_email():
    form = ChangeEmailForm()
    if form.validate_on_submit():
        current_user.email = form.email.data
        db.session.commit()
        flash("Votre adresse email a été mise à jour.", "success")
    else:
        flash("Erreur lors de la mise à jour de l'email.", "danger")
    return redirect(url_for('profile.settings'))

@profile_bp.route('/change_password', methods=['POST'])
@login_required
def change_password():
    form = ChangePasswordForm()
    if form.validate_on_submit():
        current_user.set_password(form.new_password.data)
        db.session.commit()
        flash("Votre mot de passe a été mis à jour. Veuillez vous reconnecter.", "success")
        logout_user()
        return redirect(url_for('auth.login'))
    else:
        flash("Erreur lors de la mise à jour du mot de passe.", "danger")
    return redirect(url_for('profile.settings'))

@profile_bp.route('/delete_account', methods=['POST'])
@login_required
def delete_account():
    form = DeleteAccountForm()
    if form.validate_on_submit():
        user = current_user._get_current_object()
        if isinstance(user, User):
            db.session.delete(user)
            db.session.commit()
            logout_user()
            flash("Votre compte a été supprimé.", "success")
            return redirect(url_for('main.index'))
        else:
            flash("Erreur lors de la suppression du compte.", "danger")
    else:
        flash("Erreur lors de la validation du formulaire.", "danger")
    return redirect(url_for('profile.settings'))

@profile_bp.route('/profile', methods=['GET'])
@login_required
def profile():
    user = current_user
    average_rating = user.average_rating
    total_ratings = user.ratings_received.count()
    posts = user.posts.order_by(Post.created_at.desc()).all()
    sports = Sport.query.all()
    form = EmptyForm()

    return render_template(
        'profile/profile.html',
        user=user,
        average_rating=average_rating,
        total_ratings=total_ratings,
        posts=posts,
        sports=sports,
        form=form,
        profile_image=user.profile_image or 'default_profile.jpg',
        cover_image=user.cover_image or 'default_cover.jpg'
    )

@profile_bp.route('/edit_profile', methods=['GET', 'POST'])
@login_required
def edit_profile():
    user = current_user
    form = EditProfileForm()

    if form.validate_on_submit():
        user.username = form.username.data
        user.email = form.email.data
        user.first_name = form.first_name.data
        user.last_name = form.last_name.data
        user.country = form.country.data
        user.city = form.city.data
        user.address = form.address.data
        user.postal_code = form.postal_code.data
        user.sex = form.sex.data
        user.birth_date = form.birth_date.data
        user.phone = form.phone.data
        user.display_phone = form.display_phone.data
        user.display_email = form.display_email.data
        user.latitude = form.latitude.data
        user.longitude = form.longitude.data

        if form.profile_image.data:
            profile_image = form.profile_image.data
            user.profile_image = save_image(profile_image, 'profiles', user.id)

        if form.cover_image.data:
            cover_image = form.cover_image.data
            user.cover_image = save_image(cover_image, 'covers', user.id)

        for sport in Sport.query.all():
            level = request.form.get(f'sport_{sport.id}')
            if level:
                level = int(level)
                user_sport = UserSport.query.filter_by(user_id=user.id, sport_id=sport.id).first()
                if user_sport:
                    user_sport.level = level
                else:
                    new_user_sport = UserSport(user_id=user.id, sport_id=sport.id, level=level)
                    db.session.add(new_user_sport)

        db.session.commit()
        flash("Profil mis à jour avec succès.", "success")
        return redirect(url_for('profile.profile'))

    form.username.data = user.username
    form.email.data = user.email
    form.first_name.data = user.first_name
    form.last_name.data = user.last_name
    form.country.data = user.country
    form.city.data = user.city
    form.address.data = user.address
    form.postal_code.data = user.postal_code
    form.sex.data = user.sex
    form.birth_date.data = user.birth_date
    form.phone.data = user.phone
    form.display_phone.data = user.display_phone
    form.display_email.data = user.display_email
    form.latitude.data = user.latitude
    form.longitude.data = user.longitude

    sports = Sport.query.all()
    return render_template(
        'profile/edit_profile.html',
        user=user,
        sports=sports,
        form=form
    )

@profile_bp.route('/add_friend/<int:user_id>', methods=['POST'])
@login_required
def add_friend(user_id):
    user_to_add = User.query.get_or_404(user_id)
    if user_to_add == current_user:
        flash("Vous ne pouvez pas vous ajouter vous-même.", "danger")
        return redirect(url_for('profile.profile'))

    if current_user.is_friend(user_to_add):
        flash("Vous êtes déjà amis.", "info")
    else:
        current_user.friends.append(user_to_add)
        db.session.commit()
        flash(f"Vous êtes maintenant ami avec {user_to_add.username}.", "success")

    return redirect(url_for('profile.profile'))

@profile_bp.route('/friends', methods=['GET'])
@login_required
def list_friends():
    user = current_user
    friends = user.friends.all()
    return render_template('profile/friends_list.html', friends=friends, user=user)

@profile_bp.route('/photos/<int:user_id>', methods=['GET'])
@login_required
def photos(user_id):
    user = User.query.get_or_404(user_id)
    posts = Post.query.filter_by(user_id=user_id).filter(Post.image.isnot(None)).all()
    profile_images = [user.profile_image] if user.profile_image else []
    cover_images = [user.cover_image] if user.cover_image else []
    images = profile_images + cover_images + [post.image for post in posts]

    form = EmptyForm()

    if not images:
        flash("Aucune image disponible à afficher.", "info")

    return render_template('profile/photos.html', user=user, images=images, form=form)

@profile_bp.route('/complete_profile', methods=['GET', 'POST'])
@login_required
def complete_profile():
    form = CompleteProfileForm()
    form.sports.choices = [(str(sport.id), sport.name) for sport in Sport.query.all()]
    form.levels.choices = [(str(i), f'{i} étoiles') for i in range(1, 6)]

    if form.validate_on_submit():
        current_user.birth_date = form.birth_date.data
        current_user.sex = form.sex.data

        if form.profile_image.data:
            profile_image_filename = save_image(form.profile_image.data, 'profiles', current_user.id)
            current_user.profile_image = profile_image_filename
        if form.cover_image.data:
            cover_image_filename = save_image(form.cover_image.data, 'covers', current_user.id)
            current_user.cover_image = cover_image_filename

        UserSport.query.filter_by(user_id=current_user.id).delete()
        selected_sports = form.sports.data
        selected_levels = form.levels.data
        for sport_id, level in zip(selected_sports, selected_levels):
            user_sport = UserSport(user_id=current_user.id, sport_id=int(sport_id), level=int(level))
            db.session.add(user_sport)

        db.session.commit()
        flash('Profil complété avec succès!', 'success')
        return redirect(url_for('profile.profile'))

    return render_template('profile/complete_profile.html', form=form)

@profile_bp.route('/search_users', methods=['GET'])
@login_required
def search_users():
    query = request.args.get('query', '').strip().lower()
    suggestions = []
    results = []

    if query:
        results = User.query.filter(
            (User.first_name.ilike(f'%{query}%')) | (User.last_name.ilike(f'%{query}%'))
        ).all()
    else:
        suggestions = User.query.filter(
            User.city.ilike(current_user.city),
            User.id != current_user.id
        ).limit(10).all()

    return render_template('profile/search_results.html', results=results, suggestions=suggestions, query=query)

@profile_bp.route('/add_contact/<int:user_id>', methods=['POST'])
@login_required
def add_contact(user_id):
    user_to_add = User.query.get_or_404(user_id)
    if user_to_add == current_user:
        flash("Vous ne pouvez pas vous ajouter vous-même.", "danger")
        return redirect(url_for('profile.list_contacts'))

    if current_user.is_friend(user_to_add):
        flash("Cette personne est déjà dans vos contacts.", "info")
    else:
        current_user.friends.append(user_to_add)
        db.session.commit()
        flash(f"{user_to_add.first_name} {user_to_add.last_name} a été ajouté à vos contacts.", "success")

    return redirect(url_for('profile.list_contacts'))

@profile_bp.route('/contacts', methods=['GET'])
@login_required
def list_contacts():
    contacts = current_user.friends.all()
    return render_template('profile/contacts.html', contacts=contacts)

@profile_bp.route('/remove_contact/<int:user_id>', methods=['POST'])
@login_required
def remove_contact(user_id):
    user_to_remove = User.query.get_or_404(user_id)
    if current_user.is_friend(user_to_remove):
        current_user.friends.remove(user_to_remove)
        db.session.commit()
        flash(f"{user_to_remove.first_name} {user_to_remove.last_name} a été retiré de vos contacts.", "success")
    else:
        flash("Cette personne n'est pas dans vos contacts.", "info")

    return redirect(url_for('profile.list_contacts'))


========== ./app/profile/forms.py ==========

"""
app/profile/forms.py

This module defines forms related to user profile management in the SportLink application.
It includes functionalities for editing profile information, changing passwords, updating profile and cover photos,
completing the profile, and deleting the account.

Components:
- `ChangeEmailForm`: Form to change the user's email.
- `ChangePasswordForm`: Form to change the user's password.
- `DeleteAccountForm`: Form to confirm account deletion.
- `EditProfileForm`: Form to edit profile details.
- `ChangeCoverPhotoForm`: Form to update the cover photo.
- `ChangeProfilePhotoForm`: Form to update the profile photo.
- `CompleteProfileForm`: Form to complete profile details.
- `MultiCheckboxField`: Custom field for multi-checkbox selection.
"""

from flask_wtf import FlaskForm
from wtforms import (
    StringField, PasswordField, SubmitField, BooleanField, FileField,
    SelectField, DateField, HiddenField, TelField, FloatField, SelectMultipleField
)
from wtforms.validators import DataRequired, Email, EqualTo, ValidationError, Optional
from flask_wtf.file import FileAllowed
from app.models import User
from wtforms_sqlalchemy.fields import QuerySelectMultipleField
from wtforms.widgets import ListWidget, CheckboxInput

class ChangeEmailForm(FlaskForm):
    """
    Form to allow users to change their email address.

    Fields:
    - `email`: Input for the new email (validated for format and uniqueness).
    - `submit`: Submit button to confirm email update.

    Methods:
    - `validate_email`: Checks if the email is already in use.
    """
    email = StringField('Nouvelle adresse email', validators=[DataRequired(), Email()])
    submit = SubmitField('Mettre à jour l\'email')

    def validate_email(self, email):
        if User.query.filter_by(email=email.data).first():
            raise ValidationError('Cet email est déjà utilisé.')

class ChangePasswordForm(FlaskForm):
    """
    Form to allow users to change their password.

    Fields:
    - `current_password`: Input for the current password (required).
    - `new_password`: Input for the new password (required).
    - `confirm_new_password`: Confirmation for the new password (must match).
    - `submit`: Submit button to confirm password update.
    """
    current_password = PasswordField('Mot de passe actuel', validators=[DataRequired()])
    new_password = PasswordField('Nouveau mot de passe', validators=[DataRequired()])
    confirm_new_password = PasswordField('Confirmez le nouveau mot de passe', validators=[DataRequired(), EqualTo('new_password')])
    submit = SubmitField('Mettre à jour le mot de passe')

class DeleteAccountForm(FlaskForm):
    """
    Form to confirm account deletion.

    Fields:
    - `confirm`: Checkbox to confirm the action (required).
    - `submit`: Submit button to delete the account.
    """
    confirm = BooleanField('Je confirme vouloir supprimer mon compte', validators=[DataRequired()])
    submit = SubmitField('Supprimer mon compte')

class EditProfileForm(FlaskForm):
    """
    Form to edit user profile details.

    Fields include:
    - Basic information (username, email, first/last name, address, phone, etc.).
    - Profile and cover images (optional, restricted to image formats).
    - Location data (latitude, longitude).
    - Boolean fields for displaying phone and email publicly.
    - `submit`: Submit button to update the profile.
    """
    username = StringField('Nom d\'utilisateur', validators=[DataRequired()])
    email = StringField('Email', validators=[DataRequired(), Email()])
    first_name = StringField('Prénom')
    last_name = StringField('Nom de famille')
    country = StringField('Pays')
    city = StringField('Ville')
    address = StringField('Adresse')
    postal_code = StringField('Code Postal')
    sex = SelectField(
        'Sexe',
        choices=[
            ('', 'Sélectionnez'),
            ('Male', 'Homme'),
            ('Female', 'Femme'),
            ('Other', 'Autre')
        ],
        validators=[Optional()]
    )
    birth_date = DateField('Date de Naissance', format='%Y-%m-%d', validators=[Optional()])
    phone = TelField('Numéro de Téléphone')
    display_phone = BooleanField('Afficher le numéro de téléphone')
    display_email = BooleanField('Afficher l\'email')
    profile_image = FileField('Photo de Profil', validators=[FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')])
    cover_image = FileField('Image de Couverture', validators=[FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')])
    latitude = FloatField('Latitude')
    longitude = FloatField('Longitude')
    submit = SubmitField('Mettre à Jour')

class ChangeCoverPhotoForm(FlaskForm):
    """
    Form to update the user's cover photo.

    Fields:
    - `cover_image`: File upload field for the new cover photo (required, image formats only).
    - `submit`: Submit button to update the cover photo.
    """
    cover_image = FileField('Nouvelle photo de couverture', validators=[DataRequired(), FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')])
    submit = SubmitField('Mettre à jour')

class ChangeProfilePhotoForm(FlaskForm):
    """
    Form to update the user's profile photo.

    Fields:
    - `profile_image`: File upload field for the new profile photo (required, image formats only).
    - `submit`: Submit button to update the profile photo.
    """
    profile_image = FileField('Nouvelle photo de profil', validators=[DataRequired(), FileAllowed(['jpg', 'jpeg', 'png', 'gif'], 'Images uniquement!')])
    submit = SubmitField('Mettre à jour')

class CompleteProfileForm(FlaskForm):
    """
    Form to complete the user's profile.

    Fields:
    - `birth_date`: Date field for the user's birth date (required).
    - `sex`: Dropdown to select gender (required).
    - `profile_image`: File upload for profile photo (optional, image formats only).
    - `cover_image`: File upload for cover photo (optional, image formats only).
    - `sports`: Multi-select field for sports practiced (required).
    - `levels`: Multi-select field for experience levels (1 to 5 stars, required).
    - `submit`: Submit button to save profile details.
    """
    birth_date = DateField('Date de naissance', format='%Y-%m-%d', validators=[DataRequired()])
    sex = SelectField('Sexe', choices=[('male', 'Homme'), ('female', 'Femme'), ('other', 'Autre')], validators=[DataRequired()])
    profile_image = FileField('Photo de profil', validators=[FileAllowed(['jpg', 'png', 'jpeg'], 'Images seulement!')])
    cover_image = FileField('Photo de couverture', validators=[FileAllowed(['jpg', 'png', 'jpeg'], 'Images seulement!')])
    sports = SelectMultipleField('Sports pratiqués', choices=[], validators=[DataRequired()])
    levels = SelectMultipleField('Niveaux', choices=[(str(i), f'{i} étoiles') for i in range(1, 6)], validators=[DataRequired()])
    submit = SubmitField('Enregistrer')

class MultiCheckboxField(QuerySelectMultipleField):
    """
    Custom field for rendering multiple checkboxes in a form.

    - Inherits from `QuerySelectMultipleField`.
    - Uses `ListWidget` and `CheckboxInput` for rendering.
    """
    widget = ListWidget(prefix_label=False)
    option_widget = CheckboxInput()


========== ./app/profile/__init__.py ==========

"""
app/profile/__init__.py

This module initializes the 'profile' Blueprint, which handles functionalities related to user profiles in the application.

Components:
- `profile_bp`: Blueprint instance for profile-related routes.
- Import of `routes`: Registers the routes associated with the profile Blueprint.
"""

from flask import Blueprint

# Define the Blueprint for profile-related functionalities
profile_bp = Blueprint('profile', __name__)

# Import routes to register them with the Blueprint
from app.profile import routes


========== ./app/auth/routes.py ==========

from flask import Blueprint, request, render_template, redirect, url_for, flash, current_app
from flask_login import login_user, logout_user, login_required, current_user
from app.models import User
from app.extensions import db, mail
from itsdangerous import URLSafeTimedSerializer
from flask_mail import Message
from app.auth.forms import RegistrationForm, LoginForm, ResetPasswordRequestForm, ResetPasswordForm
from flask_dance.contrib.strava import strava
from flask_dance.contrib.facebook import facebook
from app.utils.uploads_utils import allowed_file, save_file

# Define the authentication blueprint
auth_bp = Blueprint('auth', __name__)

# ============================
# OAuth Authentication Routes
# ============================

@auth_bp.route('/oauth_strava')
def oauth_strava():
    if not strava.authorized:
        current_app.logger.warning("Utilisateur non autorisé, redirection vers la connexion.")
        return redirect(url_for('auth.login'))

    token = strava.token
    current_app.logger.debug(f"Token Strava : {token}")

    resp = strava.get('/athlete')
    current_app.logger.info(f"Statut de la réponse : {resp.status_code}")
    current_app.logger.debug(f"Contenu de la réponse : {resp.text}")

    if resp.status_code != 200:
        current_app.logger.error("Erreur lors de l'appel à l'API Strava.")
        flash("Erreur de récupération des données de Strava.", "danger")
        return redirect(url_for('auth.login'))

    try:
        info = resp.json()
        current_app.logger.info(f"Données utilisateur récupérées : {info}")
    except ValueError as e:
        current_app.logger.error(f"Erreur de décodage JSON : {e}")
        flash("Erreur de lecture des données de Strava.", "danger")
        return redirect(url_for('auth.login'))

    return create_or_get_user_from_strava(info)

def create_or_get_user_from_strava(info):
    email = info.get('email')
    first_name = info.get('firstname')
    last_name = info.get('lastname')
    strava_id = info.get('id')

    if not email:
        current_app.logger.error("Aucune adresse email n'a été fournie par Strava.")
        flash("Votre compte Strava ne fournit pas d'adresse email.", "danger")
        return redirect(url_for('auth.login'))

    user = User.query.filter_by(email=email).first()

    if not user:
        user = User(
            username=email.split('@')[0],
            email=email,
            first_name=first_name,
            last_name=last_name,
            strava_id=strava_id,
            provider='strava'
        )
        db.session.add(user)
        db.session.commit()
        login_user(user)
        flash('Inscription réussie via Strava !', 'success')
        return redirect(url_for('profile.complete_profile'))
    else:
        login_user(user)
        flash('Connexion réussie via Strava.', 'success')
        return redirect(url_for('profile.profile'))

@auth_bp.route('/oauth_facebook')
def oauth_facebook():
    if not facebook.authorized:
        current_app.logger.warning("Utilisateur non autorisé, redirection vers la connexion.")
        return redirect(url_for('auth.login'))

    resp = facebook.get('/me?fields=id,name,email,first_name,last_name')
    current_app.logger.info(f"Statut de la réponse : {resp.status_code}")
    current_app.logger.debug(f"Contenu de la réponse : {resp.text}")

    if resp.status_code != 200:
        current_app.logger.error("Erreur lors de l'appel à l'API Facebook.")
        flash("Erreur de récupération des données de Facebook.", "danger")
        return redirect(url_for('auth.login'))

    try:
        info = resp.json()
        current_app.logger.info(f"Données utilisateur récupérées : {info}")
    except ValueError as e:
        current_app.logger.error(f"Erreur de décodage JSON : {e}")
        flash("Erreur de lecture des données de Facebook.", "danger")
        return redirect(url_for('auth.login'))

    return create_or_get_user_from_facebook(info)

def create_or_get_user_from_facebook(info):
    email = info.get('email')
    first_name = info.get('first_name')
    last_name = info.get('last_name')
    facebook_id = info.get('id')

    if not email:
        current_app.logger.error("Aucune adresse email n'a été fournie par Facebook.")
        flash("Votre compte Facebook ne fournit pas d'adresse email.", "danger")
        return redirect(url_for('auth.login'))

    user = User.query.filter_by(email=email).first()

    if not user:
        user = User(
            username=email.split('@')[0],
            email=email,
            first_name=first_name,
            last_name=last_name,
            facebook_id=facebook_id,
            provider='facebook'
        )
        db.session.add(user)
        db.session.commit()
        login_user(user)
        flash('Inscription réussie via Facebook !', 'success')
        return redirect(url_for('profile.complete_profile'))
    else:
        login_user(user)
        flash('Connexion réussie via Facebook.', 'success')
        return redirect(url_for('profile.profile'))

# ============================
# User Authentication Routes
# ============================

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('profile.profile'))

    form = RegistrationForm()

    if form.validate_on_submit():
        email = form.email.data.strip().lower()
        phone = form.phone.data.strip()

        # Vérification si l'email ou le téléphone existent déjà
        existing_email = User.query.filter_by(email=email).first()
        existing_phone = User.query.filter_by(phone=phone).first()

        if existing_email:
            flash("Cette adresse email est déjà utilisée. Veuillez vous connecter ou en utiliser une autre.", "warning")
            return redirect(url_for('auth.login'))

        if existing_phone:
            flash("Ce numéro de téléphone est déjà utilisé. Veuillez vous connecter ou en utiliser un autre.", "warning")
            return redirect(url_for('auth.login'))

        try:
            user = User(
                email=email,
                first_name=form.first_name.data.strip().capitalize(),
                last_name=form.last_name.data.strip().capitalize(),
                birth_date=form.birth_date.data,
                phone=phone
            )
            user.set_password(form.password.data)
            db.session.add(user)
            db.session.commit()
            flash("Inscription réussie !", "success")
            login_user(user)
            return redirect(url_for('profile.profile'))
        except Exception as e:
            flash("Une erreur s'est produite lors de l'inscription. Veuillez réessayer.", "danger")
            current_app.logger.error(f"Erreur lors de l'inscription : {e}")

    if form.errors:
        current_app.logger.debug(f"Erreurs de validation : {form.errors}")

    return render_template('auth/register.html', form=form)

@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
    if current_user.is_authenticated:
        return redirect(url_for('profile.profile'))

    form = LoginForm()

    if form.validate_on_submit():
        email = form.email.data.strip().lower()
        user = User.query.filter_by(email=email).first()

        if user is None or not user.check_password(form.password.data):
            flash("Email ou mot de passe invalide.", "danger")
            return redirect(url_for('auth.login'))

        login_user(user)
        flash("Connexion réussie.", "success")
        next_page = request.args.get('next')
        return redirect(next_page or url_for('profile.profile'))

    if form.errors:
        current_app.logger.debug(f"Erreurs de validation du formulaire : {form.errors}")

    return render_template('auth/login.html', form=form)

@auth_bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash("Vous avez été déconnecté.", "info")
    return redirect(url_for('main.index'))

# ============================
# Email and Password Management
# ============================

def send_confirmation_email(user_email):
    s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    token = s.dumps(user_email, salt='email-confirm-salt')
    confirm_url = url_for('auth.confirm_email', token=token, _external=True)
    html = render_template('auth/confirm_email.html', confirm_url=confirm_url)
    send_email('Veuillez confirmer votre email', [user_email], html)

@auth_bp.route('/confirm/<token>')
def confirm_email(token):
    s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    try:
        email = s.loads(token, salt='email-confirm-salt', max_age=3600)
    except Exception:
        flash("Le lien de confirmation est invalide ou a expiré.", "danger")
        return redirect(url_for('main.index'))

    user = User.query.filter_by(email=email).first_or_404()
    user.email_confirmed = True
    db.session.commit()
    flash("Votre email a été confirmé !", "success")
    return redirect(url_for('profile.profile'))

def send_email(subject, recipients, html_body):
    msg = Message(subject, recipients=recipients)
    msg.html = html_body
    mail.send(msg)

@auth_bp.route('/reset_password_request', methods=['GET', 'POST'])
def reset_password_request():
    if current_user.is_authenticated:
        return redirect(url_for('profile.profile'))
    form = ResetPasswordRequestForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data).first()
        if user:
            send_password_reset_email(user)
        flash('Un email avec les instructions pour réinitialiser votre mot de passe a été envoyé.', 'info')
        return redirect(url_for('auth.login'))
    return render_template('auth/reset_password_request.html', form=form)

def send_password_reset_email(user):
    s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    token = s.dumps(user.email, salt='password-reset-salt')
    reset_url = url_for('auth.reset_password', token=token, _external=True)
    html = render_template('auth/reset_password_email.html', reset_url=reset_url)
    send_email('Réinitialisation de votre mot de passe', [user.email], html)

@auth_bp.route('/reset_password/<token>', methods=['GET', 'POST'])
def reset_password(token):
    if current_user.is_authenticated:
        logout_user()

    s = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    try:
        email = s.loads(token, salt='password-reset-salt', max_age=3600)
    except Exception:
        flash('Le lien de réinitialisation est invalide ou a expiré.', 'danger')
        return redirect(url_for('auth.reset_password_request'))

    form = ResetPasswordForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=email).first_or_404()
        user.set_password(form.password.data)
        db.session.commit()
        flash('Votre mot de passe a été mis à jour. Veuillez vous reconnecter.', 'success')
        return redirect(url_for('auth.login'))

    return render_template('auth/reset_password.html', form=form, token=token)

@auth_bp.route('/upload/profile', methods=['POST'])
def upload_profile():
    if 'file' not in request.files:
        flash('No file part')
        return redirect(url_for('profile.complete_profile'))

    file = request.files['file']
    if file.filename == '':
        flash('No selected file')
        return redirect(url_for('profile.complete_profile'))

    if allowed_file(file.filename):
        folder = os.path.join(current_app.config['UPLOAD_FOLDER'], 'profiles')
        file_path = save_file(file, folder)
        flash(f'File uploaded successfully: {file_path}')
        return redirect(url_for('profile.view_profile'))
    else:
        flash('File type not allowed')
        return redirect(url_for('profile.complete_profile'))


========== ./app/auth/forms.py ==========

"""
app/auth/forms.py

This module defines the forms used for user authentication and registration functionalities in the application.
It uses Flask-WTF for form handling and WTForms for form validation.

Components:
- `RegistrationForm`: Form for user registration with fields for personal details and validation.
- `LoginForm`: Form for user login with email and password.
- `ResetPasswordRequestForm`: Form to request a password reset by email.
- `ResetPasswordForm`: Form to reset the user's password.
"""

from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField, BooleanField, DateField, SelectField
from wtforms.validators import DataRequired, Email, EqualTo, ValidationError
from app.models import User
from markupsafe import Markup
from wtforms import StringField, PasswordField, SubmitField, DateField, SelectField, BooleanField
from wtforms.validators import DataRequired, Email, EqualTo, Length, Regexp, ValidationError

class RegistrationForm(FlaskForm):
    email = StringField('Email', validators=[DataRequired(), Email()])
    first_name = StringField('Prénom', validators=[DataRequired(), Length(min=2, max=64)])
    last_name = StringField('Nom de famille', validators=[DataRequired(), Length(min=2, max=64)])
    birth_date = DateField('Date de naissance', format='%Y-%m-%d', validators=[DataRequired()])
    gender = SelectField('Genre', choices=[('male', 'Homme'), ('female', 'Femme'), ('other', 'Autre')], validators=[DataRequired()])
    phone = StringField(
        'Numéro de téléphone',
        validators=[
            DataRequired(),
            Regexp(r'^\+?\d{10,15}$', message="Entrez un numéro de téléphone valide.")
        ]
    )
    password = PasswordField('Mot de passe', validators=[DataRequired()])
    confirm_password = PasswordField(
        'Confirmez le mot de passe',
        validators=[DataRequired(), EqualTo('password')]
    )
    accept_terms = BooleanField(
        label=Markup(
        'J\'accepte les <a href="/privacy_policy" target="_blank">conditions d\'utilisation</a>'
    ),
    validators=[DataRequired(message="Vous devez accepter les conditions d'utilisation pour continuer.")]
)
    submit = SubmitField('Inscription')

    # Validation personnalisée pour vérifier si l'email est unique
    def validate_email(self, email):
        user = User.query.filter_by(email=email.data).first()
        if user:
            raise ValidationError('Cet email est déjà utilisé.')

# Form for user login
class LoginForm(FlaskForm):
    """
    This form collects the user's email and password for login.
    """
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Mot de passe', validators=[DataRequired()])
    submit = SubmitField('Connexion')

# Form for requesting a password reset
class ResetPasswordRequestForm(FlaskForm):
    """
    This form collects the user's email to send a password reset link.
    """
    email = StringField('Email', validators=[DataRequired(), Email()])
    submit = SubmitField('Réinitialiser le mot de passe')

# Form for resetting the user's password
class ResetPasswordForm(FlaskForm):
    """
    This form collects the new password and confirmation for resetting the user's password.
    """
    password = PasswordField('Nouveau mot de passe', validators=[DataRequired()])
    confirm_password = PasswordField('Confirmez le mot de passe', validators=[DataRequired(), EqualTo('password')])
    submit = SubmitField('Réinitialiser le mot de passe')


========== ./app/auth/utils.py ==========

"""
app/auth/utils.py

This module contains utility functions for user management in the authentication system.
It includes functionalities for password reset emails, token generation, and user registration for OAuth providers.

Components:
- `send_password_reset_email`: Sends a password reset email to the user.
- `generate_reset_token`: Generates a secure token for password reset.
- `register_user_if_new`: Registers a new user if they don't already exist in the database, typically for OAuth providers.
"""

from app.models import User
from app.extensions import db, mail
from flask_mail import Message
from flask import url_for, current_app
from itsdangerous import URLSafeTimedSerializer

def send_password_reset_email(user):
    """
    Sends a password reset email to the specified user.

    Parameters:
    - user: The User object representing the recipient.

    The email includes a secure token and a link for resetting the password.
    """
    token = generate_reset_token(user.email)
    msg = Message('Réinitialisation du mot de passe', recipients=[user.email])
    reset_url = url_for('auth.reset_password', token=token, _external=True)
    msg.body = f'Pour réinitialiser votre mot de passe, cliquez sur le lien suivant : {reset_url}'
    mail.send(msg)

def generate_reset_token(email):
    """
    Generates a secure token for password reset based on the user's email.

    Parameters:
    - email: The user's email address used to create the token.

    Returns:
    - A secure token that can be used to validate password reset requests.
    """
    serializer = URLSafeTimedSerializer(current_app.config['SECRET_KEY'])
    return serializer.dumps(email, salt='password-reset-salt')

def register_user_if_new(provider, provider_id, email=None, username=None):
    """
    Checks if a user exists for a given OAuth provider and provider ID. If not, registers the user.

    Parameters:
    - provider: The name of the OAuth provider (e.g., 'facebook', 'strava').
    - provider_id: The unique ID provided by the OAuth provider for the user.
    - email: Optional email address of the user.
    - username: Optional username. If not provided, defaults to a combination of provider and provider ID.

    Returns:
    - The User object for the existing or newly created user.
    """
    user = User.query.filter_by(provider=provider, provider_id=provider_id).first()

    if not user:
        user = User(
            provider=provider,
            provider_id=provider_id,
            email=email,
            username=username or f"{provider}_{provider_id}"
        )
        db.session.add(user)
        db.session.commit()

    return user


========== ./app/static/css/global.css ==========

/* Styles généraux */
body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-image: url('/static/images/background.jpg');
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-attachment: fixed;
    color: #00FF00; /* Texte vert par défaut */
}

html, body {
    height: 100%;
    display: flex;
    flex-direction: column;
}

.main-content {
    flex-grow: 1;
    min-height: calc(100vh - 80px);
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0 20px;
}

/* Header */
.header {
    position: fixed;
    top: 0;
    width: 100%;
    height: 80px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    border-bottom: 1px solid #e4e6eb;
    z-index: 1000;
}

.header-container {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
}

.logo-container img {
    height: 40px;
}

.nav .menu {
    list-style: none;
    display: flex;
    gap: 20px;
}

.nav .menu li a {
    text-decoration: none;
    color: white;
    font-weight: 500;
    transition: color 0.3s ease;
}

.nav .menu li a:hover {
    color: #00FF00;
}

.nav-title {
    flex-grow: 1;
    text-align: center;
    font-size: 2rem;
    font-weight: bold;
    color: white;
}

/* Boutons */
.btn-primary {
    display: inline-block;
    padding: 10px 20px;
    font-size: 1.2rem;
    font-weight: bold;
    color: #fff;
    text-decoration: none;
    border-radius: 10px;
    box-shadow: 0 4px 8px rgba(0, 255, 0, 0.2);
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.3s, background-color 0.3s;
    background: linear-gradient(90deg, #00FF00, #000000);
}

.btn-primary:hover {
    transform: scale(1.05);
    box-shadow: 0 6px 15px rgba(0, 255, 0, 0.4);
    background: #000000;
    color: #00FF00;
}

/* Champs de formulaire globaux */
input, textarea, select {
    background: rgba(0, 0, 0, 0.8);
    border: 1px solid #00FF00;
    color: white;
    border-radius: 5px;
    padding: 10px;
    transition: box-shadow 0.3s ease-in-out, transform 0.2s;
}

input:focus, textarea:focus, select:focus {
    box-shadow: 0 0 10px #00FF00;
    transform: scale(1.02);
    outline: none;
}

input::placeholder, textarea::placeholder {
    color: rgba(255, 255, 255, 0.6);
}

.flash-messages {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    max-width: 300px;
}

.flash-messages .alert {
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 5px;
    font-weight: bold;
    text-align: center;
    cursor: pointer;
    animation: fadeInOut 5s ease-in-out;
    transition: opacity 0.5s ease, transform 0.3s ease;
}

.alert-success {
    background-color: #28a745;
    color: white;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.alert-warning {
    background-color: #ffc107;
    color: black;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.alert-danger {
    background-color: #dc3545;
    color: white;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

/* Animation */
@keyframes fadeInOut {
    0% {
        opacity: 0;
        transform: translateY(-20px);
    }
    10% {
        opacity: 1;
        transform: translateY(0);
    }
    90% {
        opacity: 1;
        transform: translateY(0);
    }
    100% {
        opacity: 0;
        transform: translateY(-20px);
    }
}

/* Fermer le message lorsqu'on passe la souris */
.flash-messages .alert:hover {
    opacity: 0.6;
    transition: opacity 0.2s ease;
}


========== ./app/static/css/profile/profile.css ==========

/* Container principal */
.profile-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    width: 95%;
}

/* Header du profil */
.profile-header {
    position: relative;
    margin-bottom: 20px;
}

/* Photo de couverture */
.cover-photo {
    height: 300px;
    background-size: cover;
    background-position: center;
    position: relative;
    margin-top: 80px; /* Ajuste pour éviter que la navbar masque la photo */
    border-radius: 5px;
    overflow: hidden;
}

/* Photo de profil */
.profile-photo {
    width: 150px;
    height: 150px;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    border: 3px solid white;
    margin: -75px auto 10px auto; /* Position centrée */
    box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
}

/* Texte sur le profil */
.profile-text {
    color: white !important; /* Couleur blanche pour tout le texte */
    text-align: center;
}

/* Section des publications */
.posts-section {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    gap: 20px;
}

/* Publication individuelle */
.post {
    background: #fff;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.1);
}

/* Header d'une publication */
.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
}

.post-header img {
    width: 50px;
    height: 50px;
    border-radius: 50%;
}

/* Navigation */
.profile-nav ul {
    display: flex;
    gap: 15px;
    padding: 0;
    list-style: none;
    margin: 20px 0;
}

.profile-nav a {
    text-decoration: none;
    color: #555;
}

.profile-nav a:hover {
    text-decoration: underline;
}

/* Informations */
.info-card {
    background: #f9f9f9;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.1);
}

.info-card h3 {
    margin-bottom: 10px;
}

.info-card ul {
    list-style: none;
    padding: 0;
}


========== ./app/static/css/profile.css ==========

.search-container, .contacts-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    background-color: #f9f9f9;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

h1 {
    font-size: 24px;
    margin-bottom: 20px;
    color: #333;
}

.user-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

.user-list li {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 15px;
    padding: 10px;
    background-color: #fff;
    border: 1px solid #ddd;
    border-radius: 4px;
}

.user-list li img {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    margin-right: 15px;
}

.user-list li span {
    flex-grow: 1;
    font-size: 18px;
    color: #555;
}

.user-list li .btn-add,
.user-list li .btn-remove {
    padding: 5px 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.user-list li .btn-add {
    background-color: #28a745;
    color: #fff;
}

.user-list li .btn-remove {
    background-color: #dc3545;
    color: #fff;
}


========== ./app/static/css/auth/register.css ==========

/* Container spécifique pour la page d'inscription */
.register-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    padding: 20px;
    background: none;
}

.register-form {
    max-width: 500px;
    width: 100%;
    padding: 30px;
    border-radius: 10px;
    background-color: rgba(0, 0, 0, 0.8);
    box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
    text-align: center;
}

/* Titre de la page */
.register-form h2 {
    text-align: center;
    color: #00FF00;
    margin-bottom: 20px;
}

/* Champs de formulaire */
.register-form .form-group {
    margin-bottom: 20px;
}

.register-form .form-group input {
    width: 100%;
}

.register-form .form-group label {
    color: #00FF00;
    font-weight: bold;
}

/* Bouton spécifique à la page */
.register-form .btn-primary {
    width: 100%;
    font-size: 1.2rem;
}

/* Lien pour la connexion */
.register-form a {
    color: #00FF00;
    text-decoration: none;
}

.register-form a:hover {
    color: #000000;
    background-color: #00FF00;
    padding: 3px;
    border-radius: 5px;
}


========== ./app/messages/routes.py ==========

"""
app/messages/routes.py

This module defines routes for messaging functionalities in the SportLink application.
It includes features such as viewing the inbox and sending messages between users.

Components:
- `inbox`: Route for viewing received messages.
- `send_message`: Route for sending a message to another user.
"""

from flask import Blueprint, render_template, request, redirect, url_for, flash
from flask_login import login_required, current_user
from app.models import Message, User
from app.extensions import db

# Define the Blueprint for messaging-related routes
messages_bp = Blueprint('messages', __name__, template_folder='templates/messages')

@messages_bp.route('/inbox', methods=['GET'])
@login_required
def inbox():
    """
    Displays the inbox with all messages received by the current user.

    - Retrieves all messages where the recipient is the current user.
    - Orders messages by timestamp in descending order.

    Returns:
    - Rendered 'inbox.html' template with the user's messages.
    """
    messages = Message.query.filter_by(recipient_id=current_user.id).order_by(Message.timestamp.desc()).all()
    return render_template('messages/inbox.html', messages=messages)

@messages_bp.route('/send_message/<int:user_id>', methods=['GET', 'POST'])
@login_required
def send_message(user_id):
    """
    Handles sending a message to another user.

    GET:
    - Renders the message form for composing a new message.

    POST:
    - Sends the message if the form submission is valid.
    - Validates that the message body is not empty.
    - Saves the message to the database.

    Parameters:
    - user_id: ID of the recipient user.

    Returns:
    - On GET: Rendered 'send_message.html' template with the recipient's details.
    - On POST: Redirects to the inbox after the message is successfully sent.
    """
    # Retrieve the recipient user by their ID
    recipient = User.query.get_or_404(user_id)

    if request.method == 'POST':
        body = request.form.get('body')
        # Check if the message body is empty
        if not body:
            flash("Le message ne peut pas être vide.", "danger")
            return redirect(url_for('messages.send_message', user_id=user_id))
        
        # Create and save the new message
        message = Message(sender_id=current_user.id, recipient_id=recipient.id, body=body)
        db.session.add(message)
        db.session.commit()
        
        flash("Message envoyé avec succès.", "success")
        return redirect(url_for('messages.inbox'))

    return render_template('messages/send_message.html', recipient=recipient)
